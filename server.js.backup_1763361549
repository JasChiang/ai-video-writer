import express from 'express';
import cors from 'cors';
import { exec } from 'child_process';
import crypto from 'crypto';
import fs from 'fs';
import path from 'path';
import { promisify } from 'util';
import { GoogleGenAI } from '@google/genai';
import dotenv from 'dotenv';
import multer from 'multer';
import { generateFullPrompt } from './services/promptService.js';
import { generateArticlePrompt, generateArticlePromptWithReferences } from './services/articlePromptService.js';
import { AIModelManager } from './services/aiProviders/AIModelManager.js';
import { PromptTemplates } from './services/analysisPrompts/PromptTemplates.js';
import { aggregateChannelData, clearAnalyticsCache } from './services/channelAnalyticsService.js';
import { searchVideosFromCache } from './services/videoCacheService.js';
import {
  getQuotaSnapshot as getServerQuotaSnapshot,
  resetQuotaSnapshot as resetServerQuotaSnapshot,
} from './services/quotaTracker.js';
import * as taskQueue from './services/taskQueue.js';
import {
  enableArticleTemplates,
  disableArticleTemplates,
  refreshArticleTemplates,
  getArticleTemplateStatus,
  listAvailableArticleTemplates,
} from './services/articlePromptService.js';
import { publishArticleToNotion, listNotionDatabases, getNotionDatabase } from './services/notionService.js';

// è¼‰å…¥ .env.local æª”æ¡ˆ
dotenv.config({ path: '.env.local' });

const execAsync = promisify(exec);
const app = express();
const PORT = process.env.PORT || 3001;

// æª”æ¡ˆä¿ç•™å¤©æ•¸è¨­å®šï¼ˆé è¨­ 7 å¤©ï¼‰
const FILE_RETENTION_DAYS = parseInt(process.env.FILE_RETENTION_DAYS || '7', 10);

// Notion OAuth ç‹€æ…‹å„²å­˜ï¼ˆç°¡æ˜“ in-memoryï¼‰
const notionStateStore = new Map();
const NOTION_STATE_TTL_MS = 5 * 60 * 1000; // 5 åˆ†é˜æœ‰æ•ˆ

function pruneExpiredNotionStates() {
  const now = Date.now();
  for (const [state, meta] of notionStateStore.entries()) {
    if (now - meta.createdAt > NOTION_STATE_TTL_MS) {
      notionStateStore.delete(state);
    }
  }
}

// é©—è­‰ API Key
if (!process.env.GEMINI_API_KEY) {
  console.error('âŒ ERROR: GEMINI_API_KEY is not set in .env.local');
  console.error('Please add GEMINI_API_KEY=your_api_key to .env.local');
  process.exit(1);
}

console.log('âœ… Gemini API Key loaded successfully');

// åˆå§‹åŒ– Gemini AI å®¢æˆ¶ç«¯ï¼ˆç”¨æ–¼ Files API ç­‰ï¼‰
const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

// åˆå§‹åŒ– AI æ¨¡å‹ç®¡ç†å™¨
const aiManager = new AIModelManager();
const DEFAULT_MAX_TOKENS = 8192;
const MODEL_MAX_TOKEN_MAP = {
  'openai/gpt-5.1': 128000,
};

const getMaxTokensForModel = (modelType = '') => {
  if (!modelType) return DEFAULT_MAX_TOKENS;
  return MODEL_MAX_TOKEN_MAP[modelType] || DEFAULT_MAX_TOKENS;
};
console.log('âœ… AI Model Manager initialized');

app.use(cors());
app.use(express.json());

// ç¢ºä¿ä¸‹è¼‰ç›®éŒ„å­˜åœ¨
const DOWNLOAD_DIR = path.join(process.cwd(), 'temp_videos');
if (!fs.existsSync(DOWNLOAD_DIR)) {
  fs.mkdirSync(DOWNLOAD_DIR, { recursive: true });
}

// ç¢ºä¿åœ–ç‰‡ç›®éŒ„å­˜åœ¨
const IMAGES_DIR = path.join(process.cwd(), 'public', 'images');
if (!fs.existsSync(IMAGES_DIR)) {
  fs.mkdirSync(IMAGES_DIR, { recursive: true });
}

// ç¢ºä¿ä¸Šå‚³ç›®éŒ„å­˜åœ¨ï¼ˆç”¨æ–¼ Gemini Files API æš«å­˜ï¼‰
const UPLOAD_DIR = path.join(process.cwd(), 'temp_uploads');
if (!fs.existsSync(UPLOAD_DIR)) {
  fs.mkdirSync(UPLOAD_DIR, { recursive: true });
}

// è¨­å®š multer ç”¨æ–¼æª”æ¡ˆä¸Šå‚³
const upload = multer({
  dest: UPLOAD_DIR,
  limits: {
    fileSize: 100 * 1024 * 1024 // 100MB é™åˆ¶
  }
});

// éœæ…‹æª”æ¡ˆæœå‹™ - æä¾›æˆªåœ–å­˜å–
app.use('/images', express.static(IMAGES_DIR));

// å‰ç«¯åŸ·è¡ŒæœŸè¨­å®šï¼šç”±å¾Œç«¯è¼¸å‡º config.jsï¼Œé¿å…åœ¨å»ºç½®æœŸçƒ˜å…¥æ•æ„Ÿæˆ–æœƒè®Šå‹•çš„è¨­å®š
app.get('/app-config.js', (_req, res) => {
  const cfg = {
    YOUTUBE_CLIENT_ID: process.env.YOUTUBE_CLIENT_ID || null,
    YOUTUBE_SCOPES: 'https://www.googleapis.com/auth/youtube',
  };
  res.type('application/javascript').send(`window.__APP_CONFIG__ = ${JSON.stringify(cfg)};`);
});

// Quota debugging endpoints
app.get('/api/quota/server', (_req, res) => {
  try {
    const snapshot = getServerQuotaSnapshot();
    res.json(snapshot);
  } catch (error) {
    console.error('[Quota] Failed to fetch server quota snapshot:', error);
    res.status(500).json({
      error: 'FAILED_TO_FETCH_SERVER_QUOTA',
      details: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

app.post('/api/quota/server/reset', (_req, res) => {
  try {
    resetServerQuotaSnapshot();
    res.json({ success: true });
  } catch (error) {
    console.error('[Quota] Failed to reset server quota snapshot:', error);
    res.status(500).json({
      error: 'FAILED_TO_RESET_SERVER_QUOTA',
      details: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

// ==================== ä»»å‹™ç®¡ç† API ====================

/**
 * ç²å–ä»»å‹™ç‹€æ…‹
 * GET /api/task/:taskId
 */
app.get('/api/task/:taskId', (req, res) => {
  const { taskId } = req.params;

  const task = taskQueue.getTask(taskId);
  if (!task) {
    return res.status(404).json({ error: 'Task not found' });
  }

  res.json(task);
});

/**
 * åˆªé™¤/å–æ¶ˆä»»å‹™ï¼ˆä»»å‹™æœƒåœ¨å®Œæˆå¾Œè‡ªå‹•æ¸…ç†ï¼‰
 * DELETE /api/task/:taskId
 */
app.delete('/api/task/:taskId', (req, res) => {
  const { taskId } = req.params;

  const task = taskQueue.getTask(taskId);
  if (!task) {
    return res.status(404).json({ error: 'Task not found' });
  }

  // taskQueue æœƒè‡ªå‹•æ¸…ç†å·²å®Œæˆçš„ä»»å‹™ï¼Œä¸éœ€è¦æ‰‹å‹•åˆªé™¤
  res.json({
    success: true,
    message: 'Tasks are automatically cleaned up after completion. No manual deletion needed.'
  });
});

// ==================== æ¨¡æ¿ç®¡ç† API ====================

/**
 * å•Ÿç”¨è‡ªè¨‚æ¨¡æ¿
 * POST /api/templates/enable
 */
app.post('/api/templates/enable', async (req, res) => {
  try {
    await enableArticleTemplates();
    const status = getArticleTemplateStatus();
    res.json({
      success: true,
      message: 'Custom templates enabled',
      usingCustomTemplates: status.usingCustomTemplates,
      lastLoadedAt: status.lastLoadedAt
    });
  } catch (error) {
    console.error('[Templates] Enable error:', error);
    res.status(500).json({
      error: 'Failed to enable templates',
      details: error.message
    });
  }
});

/**
 * åœç”¨è‡ªè¨‚æ¨¡æ¿
 * POST /api/templates/disable
 */
app.post('/api/templates/disable', (req, res) => {
  try {
    disableArticleTemplates();
    res.json({ success: true, message: 'Custom templates disabled' });
  } catch (error) {
    console.error('[Templates] Disable error:', error);
    res.status(500).json({
      error: 'Failed to disable templates',
      details: error.message
    });
  }
});

/**
 * åˆ·æ–°æ¨¡æ¿
 * POST /api/templates/refresh
 */
app.post('/api/templates/refresh', async (req, res) => {
  try {
    const result = await refreshArticleTemplates();
    res.json({
      success: true,
      message: 'Templates refreshed',
      ...result
    });
  } catch (error) {
    console.error('[Templates] Refresh error:', error);
    res.status(500).json({
      error: 'Failed to refresh templates',
      details: error.message
    });
  }
});

/**
 * ç²å–æ¨¡æ¿ç‹€æ…‹
 * GET /api/templates/status
 */
app.get('/api/templates/status', (req, res) => {
  try {
    const status = getArticleTemplateStatus();
    res.json(status);
  } catch (error) {
    console.error('[Templates] Status error:', error);
    res.status(500).json({
      error: 'Failed to get template status',
      details: error.message
    });
  }
});

/**
 * åˆ—å‡ºå¯ç”¨æ¨¡æ¿
 * GET /api/templates
 */
app.get('/api/templates', async (req, res) => {
  try {
    const templates = await listAvailableArticleTemplates();
    const status = getArticleTemplateStatus();
    res.json({
      success: true,
      templates,
      usingCustomTemplates: status.usingCustomTemplates,
      lastLoadedAt: status.lastLoadedAt,
      disabled: status.disabled
    });
  } catch (error) {
    console.error('[Templates] List error:', error);
    res.status(500).json({
      error: 'Failed to list templates',
      details: error.message
    });
  }
});

// ==================== Notion æ•´åˆ API ====================

/**
 * ç²å– Notion OAuth URL
 * GET /api/notion/oauth/url
 */
app.get('/api/notion/oauth/url', (req, res) => {
  try {
    const clientId = process.env.NOTION_CLIENT_ID;
    const redirectUri = process.env.NOTION_REDIRECT_URI;

    if (!clientId || !redirectUri) {
      return res.status(400).json({
        error: 'Notion OAuth å°šæœªè¨­å®šï¼Œè«‹åœ¨ç’°å¢ƒè®Šæ•¸åŠ å…¥ NOTION_CLIENT_ID åŠ NOTION_REDIRECT_URIã€‚',
      });
    }

    pruneExpiredNotionStates();

    // é€é query æ˜ç¢ºå¸¶å…¥å‰ç«¯ä¾†æºï¼Œé¿å…ç€è¦½å™¨çœç•¥ Origin header æ™‚ç„¡æ³•åˆ¤åˆ¥
    let requestOrigin = null;
    if (typeof req.query.origin === 'string' && req.query.origin) {
      requestOrigin = req.query.origin;
    } else if (Array.isArray(req.query.origin) && req.query.origin.length > 0) {
      requestOrigin = req.query.origin[0];
    } else if (req.headers.origin) {
      requestOrigin = req.headers.origin;
    }

    const state = crypto.randomBytes(16).toString('hex');
    notionStateStore.set(state, {
      createdAt: Date.now(),
      origin: requestOrigin,
    });

    const notionAuthUrl = new URL('https://api.notion.com/v1/oauth/authorize');
    notionAuthUrl.searchParams.set('response_type', 'code');
    notionAuthUrl.searchParams.set('owner', 'user');
    notionAuthUrl.searchParams.set('client_id', clientId);
    notionAuthUrl.searchParams.set('redirect_uri', redirectUri);
    notionAuthUrl.searchParams.set('state', state);
    notionAuthUrl.searchParams.set('scope', 'databases.read,databases.write');

    res.json({ url: notionAuthUrl.toString(), state });
  } catch (error) {
    console.error('[Notion] ç”¢ç”Ÿæˆæ¬Š URL å¤±æ•—:', error);
    res.status(500).json({ error: 'ç„¡æ³•ç”¢ç”Ÿ Notion æˆæ¬Šç¶²å€' });
  }
});

// èˆŠç‰ˆå›å‘¼è·¯å¾‘ç›¸å®¹æ€§ï¼šå°‡ /api/notion/callback é‡æ–°å°å‘è‡³æ–°çš„ oauth/callback
app.get('/api/notion/callback', (req, res) => {
  const params = new URLSearchParams();
  Object.entries(req.query || {}).forEach(([key, value]) => {
    if (Array.isArray(value)) {
      value.forEach((item) => {
        if (item !== undefined) {
          params.append(key, String(item));
        }
      });
    } else if (value !== undefined) {
      params.append(key, String(value));
    }
  });

  const queryString = params.toString();
  const redirectPath = `/api/notion/oauth/callback${queryString ? `?${queryString}` : ''}`;
  res.redirect(302, redirectPath);
});

/**
 * Notion OAuth callback
 * GET /api/notion/oauth/callback
 */
app.get('/api/notion/oauth/callback', async (req, res) => {
  const { code, state, error, error_description: errorDescription } = req.query;

  const sendOAuthResult = (payload, targetOrigin) => {
    const safePayload = JSON.stringify(payload).replace(/</g, '\\u003c');
    const safeOrigin = targetOrigin || process.env.FRONTEND_URL || 'http://localhost:3000';
    const html = `
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Notion æˆæ¬Š</title>
  </head>
  <body style="font-family: sans-serif; display: flex; align-items: center; justify-content: center; min-height: 100vh;">
    <div>
      <p>æ­£åœ¨é—œé–‰è¦–çª—...</p>
    </div>
    <script>
      (function () {
        const payload = ${safePayload};
        if (window.opener && !window.opener.closed) {
          window.opener.postMessage({ type: 'notion:oauth:result', payload }, '${safeOrigin}');
          window.close();
        } else {
          const pre = document.createElement('pre');
          pre.textContent = JSON.stringify(payload, null, 2);
          document.body.innerHTML = '';
          document.body.appendChild(pre);
        }
      })();
    </script>
  </body>
</html>`;
    res.type('text/html').send(html);
  };

  pruneExpiredNotionStates();

  if (error) {
    console.error('[Notion] OAuth error:', error, errorDescription);
    return sendOAuthResult(
      {
        success: false,
        error,
        message: errorDescription || 'Notion æˆæ¬Šå¤±æ•—',
      },
      process.env.FRONTEND_URL
    );
  }

  if (!state || !notionStateStore.has(state)) {
    console.error('[Notion] OAuth state é©—è­‰å¤±æ•—');
    return sendOAuthResult(
      {
        success: false,
        error: 'invalid_state',
        message: 'æˆæ¬Šé€¾æ™‚æˆ–ä¾†æºç„¡æ•ˆï¼Œè«‹é‡æ–°å˜—è©¦ã€‚',
      },
      process.env.FRONTEND_URL
    );
  }

  const stateMeta = notionStateStore.get(state);
  notionStateStore.delete(state);

  if (!code) {
    return sendOAuthResult(
      {
        success: false,
        error: 'missing_code',
        message: 'æœªæ”¶åˆ°æˆæ¬Šç¢¼ï¼Œè«‹é‡æ–°å˜—è©¦ã€‚',
      },
      stateMeta?.origin || process.env.FRONTEND_URL
    );
  }

  const clientId = process.env.NOTION_CLIENT_ID;
  const clientSecret = process.env.NOTION_CLIENT_SECRET;
  const redirectUri = process.env.NOTION_REDIRECT_URI;

  if (!clientId || !clientSecret || !redirectUri) {
    console.error('[Notion] OAuth ç’°å¢ƒè®Šæ•¸æœªè¨­å®šå®Œæ•´');
    return sendOAuthResult(
      {
        success: false,
        error: 'missing_environment',
        message: 'ä¼ºæœå™¨æœªè¨­å®š Notion OAuth æ‰€éœ€ç’°å¢ƒè®Šæ•¸ã€‚',
      },
      stateMeta?.origin || process.env.FRONTEND_URL
    );
  }

  try {
    const tokenResponse = await fetch('https://api.notion.com/v1/oauth/token', {
      method: 'POST',
      headers: {
        Authorization: `Basic ${Buffer.from(`${clientId}:${clientSecret}`).toString('base64')}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        grant_type: 'authorization_code',
        code,
        redirect_uri: redirectUri,
      }),
    });

    const tokenData = await tokenResponse.json();

    if (!tokenResponse.ok) {
      console.error('[Notion] äº¤æ› token å¤±æ•—:', tokenData);
      return sendOAuthResult(
        {
          success: false,
          error: 'token_exchange_failed',
          message: tokenData?.message || 'Notion token äº¤æ›å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚',
        },
        stateMeta?.origin || process.env.FRONTEND_URL
      );
    }

    sendOAuthResult(
      {
        success: true,
        data: {
          accessToken: tokenData.access_token,
          refreshToken: tokenData.refresh_token || null,
          workspaceId: tokenData.workspace_id || null,
          workspaceName: tokenData.workspace_name || '',
          workspaceIcon: tokenData.workspace_icon || null,
          botId: tokenData.bot_id || null,
          duplicatedTemplateId: tokenData.duplicated_template_id || null,
        },
      },
      stateMeta?.origin || process.env.FRONTEND_URL
    );
  } catch (err) {
    console.error('[Notion] OAuth callback ç™¼ç”ŸéŒ¯èª¤:', err);
    sendOAuthResult(
      {
        success: false,
        error: 'unexpected_error',
        message: err.message || 'Notion æˆæ¬Šæ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤ã€‚',
      },
      stateMeta?.origin || process.env.FRONTEND_URL
    );
  }
});

/**
 * Notion OAuth å›èª¿è™•ç† (POST - èˆŠç‰ˆç›¸å®¹)
 * POST /api/notion/oauth/callback
 */
app.post('/api/notion/oauth/callback', async (req, res) => {
  const { code, state } = req.body;

  if (!code) {
    return res.status(400).json({
      error: 'Missing authorization code'
    });
  }

  const notionClientId = process.env.NOTION_CLIENT_ID;
  const notionClientSecret = process.env.NOTION_CLIENT_SECRET;
  const notionRedirectUri = process.env.NOTION_REDIRECT_URI || 'http://localhost:3000/notion-callback';

  if (!notionClientId || !notionClientSecret) {
    return res.status(500).json({
      error: 'Notion integration not configured properly'
    });
  }

  try {
    // Exchange code for access token
    const tokenResponse = await fetch('https://api.notion.com/v1/oauth/token', {
      method: 'POST',
      headers: {
        'Authorization': `Basic ${Buffer.from(`${notionClientId}:${notionClientSecret}`).toString('base64')}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        grant_type: 'authorization_code',
        code,
        redirect_uri: notionRedirectUri,
      }),
    });

    if (!tokenResponse.ok) {
      const errorText = await tokenResponse.text();
      console.error('[Notion OAuth] Token exchange failed:', errorText);
      throw new Error('Failed to exchange authorization code for token');
    }

    const tokenData = await tokenResponse.json();

    res.json({
      accessToken: tokenData.access_token,
      refreshToken: tokenData.refresh_token || null,
      workspaceId: tokenData.workspace_id || null,
      workspaceName: tokenData.workspace_name || null,
      workspaceIcon: tokenData.workspace_icon || null,
      botId: tokenData.bot_id || null,
      duplicatedTemplateId: tokenData.duplicated_template_id || null,
    });

  } catch (error) {
    console.error('[Notion OAuth] Callback error:', error);
    res.status(500).json({
      error: 'OAuth callback failed',
      details: error.message
    });
  }
});

/**
 * å–å¾— Notion è³‡æ–™åº«åˆ—è¡¨
 * POST /api/notion/databases
 */
app.post('/api/notion/databases', async (req, res) => {
  try {
    const { notionToken, pageSize, startCursor } = req.body || {};

    if (!notionToken) {
      return res.status(400).json({
        error: 'ç¼ºå°‘ Notion Access Token',
      });
    }

    const parsedPageSize = pageSize ? parseInt(pageSize, 10) : undefined;

    const result = await listNotionDatabases(notionToken, {
      pageSize: parsedPageSize,
      startCursor: startCursor || undefined,
    });

    res.json(result);
  } catch (error) {
    console.error('[Notion] å–å¾—è³‡æ–™åº«åˆ—è¡¨å¤±æ•—:', error);
    const statusCode = error?.statusCode && Number.isInteger(error.statusCode) ? error.statusCode : 500;
    res.status(statusCode).json({
      error: error.message || 'å–å¾— Notion è³‡æ–™åº«åˆ—è¡¨å¤±æ•—',
    });
  }
});

/**
 * å–å¾—æŒ‡å®š Notion è³‡æ–™åº«çš„æ¬„ä½è³‡è¨Š
 * POST /api/notion/database-info
 */
app.post('/api/notion/database-info', async (req, res) => {
  try {
    const { notionToken, databaseId } = req.body || {};

    if (!notionToken || !databaseId) {
      return res.status(400).json({
        error: 'ç¼ºå°‘ Notion Access Token æˆ–è³‡æ–™åº« ID',
      });
    }

    const databaseInfo = await getNotionDatabase(notionToken, databaseId);

    res.json(databaseInfo);
  } catch (error) {
    console.error('[Notion] å–å¾—è³‡æ–™åº«è³‡è¨Šå¤±æ•—:', error);
    const statusCode = error?.statusCode && Number.isInteger(error.statusCode) ? error.statusCode : 500;
    res.status(statusCode).json({
      error: error.message || 'å–å¾— Notion è³‡æ–™åº«è³‡è¨Šå¤±æ•—',
    });
  }
});

// ==================== å®‰å…¨æ€§é©—è­‰å‡½æ•¸ ====================

/**
 * é©—è­‰ YouTube Video ID æ ¼å¼
 * YouTube Video ID æ ¼å¼ï¼š11 å€‹å­—å…ƒï¼Œåƒ…å…è¨± a-z, A-Z, 0-9, -, _
 * @param {string} videoId - è¦é©—è­‰çš„ Video ID
 * @returns {boolean} - æ˜¯å¦ç‚ºæœ‰æ•ˆæ ¼å¼
 */
function isValidVideoId(videoId) {
  if (!videoId || typeof videoId !== 'string') {
    return false;
  }
  // YouTube Video ID å›ºå®šç‚º 11 å€‹å­—å…ƒ
  return /^[a-zA-Z0-9_-]{11}$/.test(videoId);
}

// ==================== æˆªåœ–å·¥å…·å‡½æ•¸ ====================

/**
 * å°‡æ™‚é–“å­—ä¸²ï¼ˆmm:ssï¼‰è½‰æ›ç‚ºç§’æ•¸
 * @param {string} timeStr - æ™‚é–“å­—ä¸²ï¼ˆæ ¼å¼ï¼šmm:ssï¼‰
 * @returns {number} - ç§’æ•¸
 */
function timeToSeconds(timeStr) {
  const [minutes, seconds] = timeStr.split(':').map(Number);
  return minutes * 60 + seconds;
}

/**
 * å°‡ç§’æ•¸è½‰æ›ç‚ºæ™‚é–“å­—ä¸²ï¼ˆmm:ssï¼‰
 * @param {number} seconds - ç§’æ•¸
 * @returns {string} - æ™‚é–“å­—ä¸²ï¼ˆæ ¼å¼ï¼šmm:ssï¼‰
 */
function secondsToTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
}

/**
 * ä½¿ç”¨ FFmpeg æˆªå–å½±ç‰‡ç•«é¢
 * @param {string} videoPath - å½±ç‰‡æª”æ¡ˆè·¯å¾‘
 * @param {number} timeInSeconds - æˆªåœ–æ™‚é–“é»ï¼ˆç§’ï¼‰
 * @param {string} outputPath - è¼¸å‡ºæª”æ¡ˆè·¯å¾‘
 * @param {number} quality - æˆªåœ–å“è³ªï¼ˆ2-31ï¼Œæ•¸å­—è¶Šå°å“è³ªè¶Šé«˜ï¼‰ï¼Œé è¨­ 2ï¼ˆæœ€é«˜å“è³ªï¼‰
 * @returns {Promise<void>}
 */
async function captureScreenshot(videoPath, timeInSeconds, outputPath, quality = 2) {
  // é™åˆ¶å“è³ªç¯„åœåœ¨ 2-31 ä¹‹é–“
  const validQuality = Math.max(2, Math.min(31, quality));

  // FFmpeg æˆªåœ–å‘½ä»¤
  // -ss: æŒ‡å®šæ™‚é–“é»
  // -i: è¼¸å…¥æª”æ¡ˆ
  // -vframes 1: åªæˆªå–ä¸€å¹€
  // -q:v: JPEG å“è³ªï¼ˆ2=æœ€é«˜å“è³ªï¼Œ31=æœ€ä½å“è³ªï¼‰
  // -y: è¦†è“‹å·²å­˜åœ¨çš„æª”æ¡ˆ
  const command = `ffmpeg -ss ${timeInSeconds} -i "${videoPath}" -vframes 1 -q:v ${validQuality} "${outputPath}" -y`;
  await execAsync(command);
}

// =============== Files API helpers ===============
/**
 * ä½¿ç”¨ Files API ä»¥ displayName å°‹æ‰¾æª”æ¡ˆï¼ˆæ”¯æ´åˆ†é ï¼‰ã€‚
 * å›å‚³ç¬¬ä¸€å€‹ç¬¦åˆ displayName çš„æª”æ¡ˆï¼ˆå¯ç‚ºä»»ä½• stateï¼‰ã€‚
 */
async function findFileByDisplayName(ai, displayName) {
  try {
    const iterable = await ai.files.list({ config: { pageSize: 50 } });
    for await (const file of iterable) {
      if (file?.displayName === displayName) {
        return file;
      }
    }
    return null;
  } catch (err) {
    console.error('[FilesAPI] list error:', err?.message || err);
    throw err;
  }
}

// ==================== API ç«¯é» ====================

/**
 * ä¸‹è¼‰ YouTube å½±ç‰‡
 * POST /api/download-video
 * Body: { videoId: string, accessToken: string, quality?: number }
 */
app.post('/api/download-video', async (req, res) => {
  const { videoId, accessToken, quality = 2 } = req.body;

  if (!videoId || !isValidVideoId(videoId)) {
    return res.status(400).json({ error: 'Missing or invalid videoId format' });
  }

  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
  const outputPath = path.join(DOWNLOAD_DIR, `${videoId}.mp4`);

  try {
    console.log(`\n========== ğŸ¬ é–‹å§‹ä¸‹è¼‰å½±ç‰‡ ==========`);
    console.log(`[Download] Video ID: ${videoId}`);
    console.log(`[Download] Video URL: ${videoUrl}`);

    // æª¢æŸ¥ yt-dlp æ˜¯å¦å®‰è£
    console.log(`[Download] Checking yt-dlp installation...`);
    try {
      const { stdout } = await execAsync('yt-dlp --version');
      console.log(`[Download] âœ… yt-dlp version: ${stdout.trim()}`);
    } catch (error) {
      console.error(`[Download] âŒ yt-dlp not found`);
      return res.status(500).json({
        error: 'yt-dlp is not installed. Please install it: https://github.com/yt-dlp/yt-dlp#installation'
      });
    }

    // ä½¿ç”¨ yt-dlp ä¸‹è¼‰æœªåˆ—å‡ºå½±ç‰‡
    // ä¸ä½¿ç”¨ cookiesï¼Œä¾è³´ yt-dlp çš„å…§å»ºæ©Ÿåˆ¶

    // æ ¹æ“šæˆªåœ–å“è³ªæ±ºå®šå½±ç‰‡è§£æåº¦
    // quality=2ï¼ˆé«˜ç•«è³ªæˆªåœ–ï¼‰â†’ ä¸‹è¼‰ 1080p å½±ç‰‡ï¼ˆè‡³å°‘ 720pï¼‰
    // quality=20ï¼ˆå£“ç¸®æˆªåœ–ï¼‰â†’ ä¸‹è¼‰ 720p å½±ç‰‡ï¼ˆè‡³å°‘ 480pï¼‰
    let formatSelector;
    if (quality <= 10) {
      // é«˜å“è³ªï¼šå„ªå…ˆ 1080pï¼Œæ¬¡é¸ 720pï¼Œæœ€å¾Œæ¥å— >=480p æˆ–æœ€ä½³
      formatSelector = '"bestvideo[height<=1080][ext=mp4]+bestaudio[ext=m4a]/bestvideo[height<=1080]+bestaudio/best[height<=1080]/bestvideo[height<=720][ext=mp4]+bestaudio[ext=m4a]/bestvideo[height<=720]+bestaudio/best[height<=720]/best"';
      console.log(`[Download] æˆªåœ–å“è³ª: ${quality}ï¼ˆé«˜ç•«è³ªï¼‰â†’ ç›®æ¨™å½±ç‰‡è§£æåº¦: 1080p (é€€å› 720p)`);
    } else {
      // å£“ç¸®ï¼šå„ªå…ˆ 720pï¼Œæ¬¡é¸ 480pï¼Œæœ€å¾Œæ¥å— 360p æˆ–æœ€ä½³
      formatSelector = '"bestvideo[height<=720][ext=mp4]+bestaudio[ext=m4a]/bestvideo[height<=720]+bestaudio/best[height<=720]/bestvideo[height<=480][ext=mp4]+bestaudio[ext=m4a]/bestvideo[height<=480]+bestaudio/best[height<=480]/best"';
      console.log(`[Download] æˆªåœ–å“è³ª: ${quality}ï¼ˆå£“ç¸®ï¼‰â†’ ç›®æ¨™å½±ç‰‡è§£æåº¦: 720p (é€€å› 480p)`);
    }

    // å»ºæ§‹å‘½ä»¤ï¼ˆä½¿ç”¨é™£åˆ—é¿å…æ›è¡Œå•é¡Œï¼‰
    // æ³¨æ„ï¼šä¸ä½¿ç”¨ android clientï¼Œå› ç‚ºå®ƒé™åˆ¶åªèƒ½ä¸‹è¼‰ 360p
    // å°æ–¼æœªåˆ—å‡ºçš„å½±ç‰‡ï¼Œç¾ä»£ yt-dlp å¯ä»¥ä¸éœ€è¦ cookies ç›´æ¥ä¸‹è¼‰
    const commandParts = [
      'yt-dlp',
      // æ ¹æ“šå“è³ªé¸æ“‡æ ¼å¼
      '-f', formatSelector,
      // å¦‚æœä¸‹è¼‰åˆ†é›¢çš„éŸ³è¦–é »æµï¼Œåˆä½µç‚º mp4
      '--merge-output-format', 'mp4',
      '-o', `"${outputPath}"`,
      // å¢åŠ é‡è©¦æ¬¡æ•¸
      '--retries', '5',
      '--fragment-retries', '5',
      // æ·»åŠ å½±ç‰‡ URL
      `"${videoUrl}"`,
    ];

    const command = commandParts.join(' ');

    console.log(`[Download] Executing command:\n${command}`);
    console.log(`[Download] æ­£åœ¨ä¸‹è¼‰å½±ç‰‡,è«‹ç¨å€™...`);

    const { stdout, stderr } = await execAsync(command, { maxBuffer: 10 * 1024 * 1024 });

    if (stdout) console.log('[Download] yt-dlp output:', stdout);
    if (stderr) console.log('[Download] yt-dlp warnings:', stderr);

    if (!fs.existsSync(outputPath)) {
      throw new Error('Video download failed - file not found');
    }

    const stats = fs.statSync(outputPath);
    const fileSizeMB = (stats.size / (1024 * 1024)).toFixed(2);
    console.log(`[Download] âœ… å½±ç‰‡ä¸‹è¼‰æˆåŠŸ!`);
    console.log(`[Download] æª”æ¡ˆè·¯å¾‘: ${outputPath}`);
    console.log(`[Download] æª”æ¡ˆå¤§å°: ${fileSizeMB} MB`);
    console.log(`========== ä¸‹è¼‰å®Œæˆ ==========\n`);

    res.json({
      success: true,
      filePath: outputPath,
      videoId
    });

  } catch (error) {
    console.error('Download error:', error);

    // æä¾›æ›´è©³ç´°çš„éŒ¯èª¤è¨Šæ¯
    let errorDetails = error.message;
    if (error.stderr) {
      errorDetails += `\nstderr: ${error.stderr}`;
    }
    if (error.stdout) {
      errorDetails += `\nstdout: ${error.stdout}`;
    }

    res.status(500).json({
      error: 'Failed to download video',
      details: errorDetails,
      videoId,
      videoUrl
    });
  }
});

/**
 * ä½¿ç”¨ YouTube URL ç›´æ¥åˆ†æå½±ç‰‡ï¼ˆåƒ…é™å…¬é–‹å½±ç‰‡ï¼‰
 * POST /api/analyze-video-url
 * Body: { videoId: string, prompt: string, videoTitle: string }
 */
app.post('/api/analyze-video-url', async (req, res) => {
  const { videoId, prompt, videoTitle } = req.body;

  if (!videoId || !isValidVideoId(videoId)) {
    return res.status(400).json({ error: 'Missing or invalid videoId format' });
  }

  const youtubeUrl = `https://www.youtube.com/watch?v=${videoId}`;

  try {
    console.log(`\n========== ğŸ¤– ä½¿ç”¨ YouTube URL åˆ†æå½±ç‰‡ ==========`);
    console.log(`[Analyze URL] Video ID: ${videoId}`);
    console.log(`[Analyze URL] YouTube URL: ${youtubeUrl}`);
    console.log(`[Analyze URL] Video Title: ${videoTitle}`);

    const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

    // ç”Ÿæˆæç¤ºè©
    console.log('[Analyze URL] æ­£åœ¨ç”Ÿæˆ SEO å¼·åŒ–å…§å®¹...');
    const fullPrompt = generateFullPrompt(videoTitle, prompt);

    // ç›´æ¥ä½¿ç”¨ YouTube URL å‘¼å« Gemini API
    // æ ¹æ“šæœ€ä½³å¯¦è¸ï¼šå½±ç‰‡æ‡‰è©²æ”¾åœ¨ prompt ä¹‹å‰
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: [
        {
          role: 'user',
          parts: [
            { fileData: { fileUri: youtubeUrl } },
            { text: fullPrompt }
          ]
        }
      ],
      config: {
        responseMimeType: "application/json",
        maxOutputTokens: 8192,  // è¨­å®šè¼ƒé«˜çš„ token ä¸Šé™ï¼Œé¿å…ç”Ÿæˆçµæœè¢«æˆªæ–·
      },
    });

    console.log('[Analyze URL] âœ… Gemini åˆ†æå®Œæˆ!');
    const result = JSON.parse(response.text);
    console.log(`[Analyze URL] Generated: ${result.titleA}`);
    console.log(`========== åˆ†æå®Œæˆ ==========\n`);

    res.json({
      success: true,
      metadata: result,
      usedYouTubeUrl: true
    });

  } catch (error) {
    console.error('Analysis error:', error);
    res.status(500).json({
      error: 'Failed to analyze video via YouTube URL',
      details: error.message
    });
  }
});

/**
 * ä½¿ç”¨ YouTube URL ç›´æ¥åˆ†æå½±ç‰‡ï¼ˆç•°æ­¥ç‰ˆæœ¬ï¼Œé©åˆæ‰‹æ©Ÿç«¯ï¼‰
 * POST /api/analyze-video-url-async
 * Body: { videoId: string, prompt: string, videoTitle: string }
 */
app.post('/api/analyze-video-url-async', async (req, res) => {
  const { videoId, prompt, videoTitle } = req.body;

  if (!videoId || !isValidVideoId(videoId)) {
    return res.status(400).json({ error: 'Missing or invalid videoId format' });
  }

  try {
    console.log(`\n========== ğŸ¤– [ç•°æ­¥] ä½¿ç”¨ YouTube URL åˆ†æå½±ç‰‡ ==========`);
    console.log(`[Analyze URL Async] Video ID: ${videoId}`);
    console.log(`[Analyze URL Async] Video Title: ${videoTitle}`);

    // å‰µå»ºç•°æ­¥ä»»å‹™
    const taskId = taskQueue.createTask('analyze-video-url', {
      videoId,
      prompt,
      videoTitle
    });

    console.log(`[Analyze URL Async] Task created: ${taskId}`);
    res.json({ taskId });

    // åœ¨èƒŒæ™¯åŸ·è¡Œä»»å‹™
    taskQueue.executeTask(taskId, async (taskId) => {
      const youtubeUrl = `https://www.youtube.com/watch?v=${videoId}`;

      taskQueue.updateTaskProgress(taskId, 10, 'æ­£åœ¨åˆå§‹åŒ– Gemini AI...');
      const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

      taskQueue.updateTaskProgress(taskId, 30, 'æ­£åœ¨ç”Ÿæˆ SEO å¼·åŒ–å…§å®¹...');
      const fullPrompt = generateFullPrompt(videoTitle, prompt);

      taskQueue.updateTaskProgress(taskId, 50, 'æ­£åœ¨ä½¿ç”¨ YouTube URL åˆ†æå½±ç‰‡...');
      const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: [
          {
            role: 'user',
            parts: [
              { fileData: { fileUri: youtubeUrl } },
              { text: fullPrompt }
            ]
          }
        ],
        config: {
          responseMimeType: "application/json",
          maxOutputTokens: 8192,
        },
      });

      taskQueue.updateTaskProgress(taskId, 90, 'æ­£åœ¨è§£æ Gemini å›æ‡‰...');
      const result = JSON.parse(response.text);

      console.log(`[Analyze URL Async] âœ… åˆ†æå®Œæˆ: ${result.titleA}`);

      return {
        success: true,
        metadata: result,
        usedYouTubeUrl: true
      };
    });

  } catch (error) {
    console.error('[Analyze URL Async] Error:', error);
    res.status(500).json({
      error: 'Failed to create async analysis task',
      details: error.message
    });
  }
});

// ï¼ˆMoved to bottomï¼‰

/**
 * ä¸Šå‚³å½±ç‰‡åˆ° Gemini ä¸¦ç”Ÿæˆ metadataï¼ˆç”¨æ–¼éå…¬é–‹å½±ç‰‡ï¼‰
 * POST /api/analyze-video
 * Body: { videoId: string, filePath?: string, prompt: string, videoTitle: string }
 */
app.post('/api/analyze-video', async (req, res) => {
  const { videoId, filePath, prompt, videoTitle } = req.body;

  if (!videoId || !isValidVideoId(videoId)) {
    return res.status(400).json({ error: 'Missing or invalid videoId format' });
  }

  try {
    console.log(`\n========== ğŸ¤– é–‹å§‹åˆ†æå½±ç‰‡ ==========`);
    console.log(`[Analyze] Video ID: ${videoId}`);
    console.log(`[Analyze] File Path: ${filePath || '(not provided, will check Files API)'}`);
    console.log(`[Analyze] Video Title: ${videoTitle}`);

    const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

    // å…ˆæª¢æŸ¥æª”æ¡ˆæ˜¯å¦å·²å­˜åœ¨æ–¼ Files API
    console.log('[Analyze] æ­¥é©Ÿ 1/4: æª¢æŸ¥ Files API ä¸­æ˜¯å¦å·²æœ‰æ­¤æª”æ¡ˆ...');
    const existingFile = await findFileByDisplayName(ai, videoId);

    let uploadedFile;
    let reusedFile = false;

    if (existingFile) {
      console.log(`[Analyze] âœ… æ‰¾åˆ°å·²å­˜åœ¨çš„æª”æ¡ˆï¼Œå°‡é‡è¤‡ä½¿ç”¨ï¼`);
      console.log(`[Analyze] File Name: ${existingFile.name}`);
      console.log(`[Analyze] Display Name: ${existingFile.displayName}`);
      console.log(`[Analyze] File URI: ${existingFile.uri}`);
      console.log(`[Analyze] è·³éä¸Šå‚³æ­¥é©Ÿï¼Œç¯€çœæ™‚é–“å’Œæµé‡ï¼`);
      uploadedFile = existingFile;
      reusedFile = true;

      // åˆªé™¤æœ¬åœ°å·²ä¸‹è¼‰çš„æš«å­˜æª”æ¡ˆï¼ˆå¦‚æœæœ‰æä¾›çš„è©±ï¼‰
      if (filePath && fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
        console.log(`[Analyze] ğŸ—‘ï¸  å·²åˆªé™¤ä¸éœ€è¦çš„æš«å­˜æª”æ¡ˆ: ${filePath}`);
      }
    } else {
      // æª”æ¡ˆä¸å­˜åœ¨æ–¼ Files API
      if (!filePath) {
        return res.status(400).json({
          error: 'File not found in Files API and no filePath provided for upload'
        });
      }

      console.log('[Analyze] æª”æ¡ˆä¸å­˜åœ¨ï¼Œéœ€è¦ä¸Šå‚³...');
      // ä¸Šå‚³å½±ç‰‡åˆ° Geminiï¼ˆä½¿ç”¨ videoId ä½œç‚º displayNameï¼‰
      uploadedFile = await ai.files.upload({
        file: filePath,
        config: {
          mimeType: 'video/mp4',
          displayName: videoId  // ä½¿ç”¨ videoId ä½œç‚ºæª”æ¡ˆåç¨±ï¼Œæ–¹ä¾¿å¾ŒçºŒæŸ¥æ‰¾
        },
      });

      console.log(`[Analyze] âœ… æª”æ¡ˆå·²ä¸Šå‚³`);
      console.log(`[Analyze] File Name (ç³»çµ±ç”Ÿæˆ): ${uploadedFile.name}`);
      console.log(`[Analyze] Display Name (æˆ‘å€‘è¨­å®š): ${uploadedFile.displayName}`);
      console.log(`[Analyze] File URI: ${uploadedFile.uri}`);
      console.log(`[Analyze] File State: ${uploadedFile.state}`);
    }

    // ç­‰å¾…æª”æ¡ˆè™•ç†å®Œæˆï¼ˆè®Šæˆ ACTIVE ç‹€æ…‹ï¼‰
    if (uploadedFile.state === 'PROCESSING') {
        console.log('[Analyze] â³ Gemini æ­£åœ¨è™•ç†å½±ç‰‡,ç­‰å¾…è™•ç†å®Œæˆ...');

        let attempts = 0;
        const maxAttempts = 60; // æœ€å¤šç­‰å¾… 60 æ¬¡ï¼ˆç´„ 5 åˆ†é˜ï¼‰
        let isActive = false;

        while (!isActive && attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 5000)); // ç­‰å¾… 5 ç§’

          try {
            // ä½¿ç”¨ files.get() ä¾†æª¢æŸ¥ç‰¹å®šæª”æ¡ˆçš„ç‹€æ…‹
            const fetchedFile = await ai.files.get({ name: uploadedFile.name });

            if (fetchedFile) {
              const progress = Math.round(((attempts + 1) / maxAttempts) * 100);
              console.log(`[Analyze] æª¢æŸ¥ç‹€æ…‹ ${attempts + 1}/${maxAttempts} (${progress}%) - State: ${fetchedFile.state}`);

              if (fetchedFile.state === 'ACTIVE') {
                isActive = true;
                console.log('[Analyze] âœ… æª”æ¡ˆè™•ç†å®Œæˆ,å¯ä»¥é–‹å§‹åˆ†æ!');
              } else if (fetchedFile.state === 'FAILED') {
                throw new Error('File processing failed');
              }
            }
          } catch (error) {
            console.log(`[Analyze] âš ï¸  æª¢æŸ¥ ${attempts + 1}/${maxAttempts} æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message}`);
            // ç¹¼çºŒå˜—è©¦
          }

          attempts++;
        }

        if (!isActive) {
          throw new Error('File processing timeout. Please try again later.');
        }
      } else if (uploadedFile.state === 'ACTIVE') {
        console.log('[Analyze] âœ… æª”æ¡ˆå·²ç¶“æ˜¯ ACTIVE ç‹€æ…‹');
      } else {
        throw new Error(`Unexpected file state: ${uploadedFile.state}`);
      }

    // ç”Ÿæˆæç¤ºè©
    console.log('[Analyze] æ­¥é©Ÿ 4/4: æ­£åœ¨ç”Ÿæˆ SEO å¼·åŒ–å…§å®¹...');
    const fullPrompt = generateFullPrompt(videoTitle, prompt);

    // å‘¼å« Gemini API
    // æ ¹æ“šæœ€ä½³å¯¦è¸ï¼šå½±ç‰‡æ‡‰è©²æ”¾åœ¨ prompt ä¹‹å‰
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: [
        {
          role: 'user',
          parts: [
            { fileData: { fileUri: uploadedFile.uri, mimeType: 'video/mp4' } },
            { text: fullPrompt }
          ]
        }
      ],
      config: {
        responseMimeType: "application/json",
        maxOutputTokens: 8192,  // è¨­å®šè¼ƒé«˜çš„ token ä¸Šé™ï¼Œé¿å…ç”Ÿæˆçµæœè¢«æˆªæ–·
      },
    });

    console.log('[Analyze] âœ… Gemini åˆ†æå®Œæˆ!');
    const result = JSON.parse(response.text);
    console.log(`[Analyze] Generated: ${result.titleA}`);

    // æ¸…ç†æš«å­˜æª”æ¡ˆï¼ˆå¦‚æœé‚„å­˜åœ¨çš„è©±ï¼‰
    if (!reusedFile && filePath && fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
      console.log(`[Analyze] ğŸ—‘ï¸  å·²åˆªé™¤æš«å­˜æª”æ¡ˆ: ${filePath}`);
    }
    console.log(`========== åˆ†æå®Œæˆ ==========\n`);

    res.json({
      success: true,
      metadata: result,
      geminiFileName: uploadedFile.name,
      geminiFileUri: uploadedFile.uri
    });

  } catch (error) {
    console.error('Analysis error:', error);

    // æ¸…ç†æš«å­˜æª”æ¡ˆ
    if (filePath && fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }

    res.status(500).json({
      error: 'Failed to analyze video',
      details: error.message
    });
  }
});

/**
 * æª¢æŸ¥ Gemini æª”æ¡ˆæ˜¯å¦ä»ç„¶å­˜åœ¨ä¸¦é‡æ–°åˆ†æ
 * POST /api/reanalyze-with-existing-file
 * Body: { geminiFileName: string, prompt: string, videoTitle: string }
 */
app.post('/api/reanalyze-with-existing-file', async (req, res) => {
  const { geminiFileName, prompt, videoTitle } = req.body;

  if (!geminiFileName) {
    return res.status(400).json({ error: 'Missing geminiFileName' });
  }

  try {
    console.log(`Checking if Gemini file exists: ${geminiFileName}`);

    const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

    // å˜—è©¦å–å¾—æª”æ¡ˆ
    let fileInfo;
    try {
      fileInfo = await ai.files.get({ name: geminiFileName });
    } catch (error) {
      console.log(`File not found or error: ${error.message}`);
      return res.status(404).json({ error: 'File not found', needsRedownload: true });
    }

    // æª¢æŸ¥æª”æ¡ˆç‹€æ…‹
    if (fileInfo.state === 'FAILED') {
      return res.status(404).json({ error: 'File processing failed', needsRedownload: true });
    }

    if (fileInfo.state !== 'ACTIVE') {
      return res.status(400).json({ error: 'File is not ready', state: fileInfo.state });
    }

    console.log(`âœ… File found and active: ${fileInfo.uri}`);

    // ç”Ÿæˆæç¤ºè©ï¼ˆèˆ‡ analyze-video ç›¸åŒï¼‰
    const fullPrompt = generateFullPrompt(videoTitle, prompt);

    // å‘¼å« Gemini API
    // æ ¹æ“šæœ€ä½³å¯¦è¸ï¼šå½±ç‰‡æ‡‰è©²æ”¾åœ¨ prompt ä¹‹å‰
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: [
        {
          role: 'user',
          parts: [
            { fileData: { fileUri: fileInfo.uri, mimeType: 'video/mp4' } },
            { text: fullPrompt }
          ]
        }
      ],
      config: {
        responseMimeType: "application/json",
        maxOutputTokens: 8192,  // è¨­å®šè¼ƒé«˜çš„ token ä¸Šé™ï¼Œé¿å…ç”Ÿæˆçµæœè¢«æˆªæ–·
      },
    });

    const result = JSON.parse(response.text);

    res.json({
      success: true,
      metadata: result,
      geminiFileName: fileInfo.name,
      geminiFileUri: fileInfo.uri,
      reusedExistingFile: true
    });

  } catch (error) {
    console.error('Reanalysis error:', error);
    res.status(500).json({
      error: 'Failed to reanalyze video',
      details: error.message
    });
  }
});

/**
 * ä¸Šå‚³åƒè€ƒæª”æ¡ˆåˆ° Gemini Files API
 * POST /api/gemini/upload-file
 * Content-Type: multipart/form-data
 * Body: FormData with 'file' field
 */
app.post('/api/gemini/upload-file', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    console.log(`[Gemini Upload] æ”¶åˆ°æª”æ¡ˆä¸Šå‚³è«‹æ±‚: ${req.file.originalname}`);
    console.log(`[Gemini Upload] æª”æ¡ˆå¤§å°: ${(req.file.size / 1024 / 1024).toFixed(2)} MB`);
    console.log(`[Gemini Upload] MIME Type: ${req.file.mimetype}`);

    // è®€å–æš«å­˜æª”æ¡ˆ
    const filePath = req.file.path;

    // ä¸Šå‚³åˆ° Gemini Files API
    const uploadedFile = await ai.files.upload({
      file: filePath,
      config: {
        mimeType: req.file.mimetype,
        displayName: req.file.originalname
      }
    });

    console.log(`[Gemini Upload] âœ… æª”æ¡ˆä¸Šå‚³æˆåŠŸ`);
    console.log(`[Gemini Upload] File Name: ${uploadedFile.name}`);
    console.log(`[Gemini Upload] File URI: ${uploadedFile.uri}`);
    console.log(`[Gemini Upload] File State: ${uploadedFile.state}`);

    // ç­‰å¾…æª”æ¡ˆè™•ç†å®Œæˆ
    if (uploadedFile.state === 'PROCESSING') {
      console.log('[Gemini Upload] â³ ç­‰å¾… Gemini è™•ç†æª”æ¡ˆ...');
      let attempts = 0;
      const maxAttempts = 30;
      let isActive = false;

      while (!isActive && attempts < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, 2000));
        try {
          const fetchedFile = await ai.files.get({ name: uploadedFile.name });
          if (fetchedFile.state === 'ACTIVE') {
            isActive = true;
            console.log('[Gemini Upload] âœ… æª”æ¡ˆè™•ç†å®Œæˆ');
          } else if (fetchedFile.state === 'FAILED') {
            throw new Error('File processing failed');
          }
        } catch (error) {
          console.log(`[Gemini Upload] âš ï¸  æª¢æŸ¥ç‹€æ…‹æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message}`);
        }
        attempts++;
      }

      if (!isActive) {
        throw new Error('File processing timeout');
      }
    }

    // åˆªé™¤æš«å­˜æª”æ¡ˆ
    try {
      fs.unlinkSync(filePath);
      console.log(`[Gemini Upload] ğŸ—‘ï¸  å·²åˆªé™¤æš«å­˜æª”æ¡ˆ: ${filePath}`);
    } catch (err) {
      console.warn(`[Gemini Upload] âš ï¸  ç„¡æ³•åˆªé™¤æš«å­˜æª”æ¡ˆ: ${err.message}`);
    }

    // è¿”å›æª”æ¡ˆè³‡è¨Šï¼ˆç¬¦åˆå‰ç«¯ UploadedFile ä»‹é¢ï¼‰
    res.json({
      name: uploadedFile.name,
      uri: uploadedFile.uri,
      mimeType: uploadedFile.mimeType,
      displayName: uploadedFile.displayName,
      sizeBytes: uploadedFile.sizeBytes
    });

  } catch (error) {
    console.error('[Gemini Upload] Error:', error);

    // æ¸…ç†æš«å­˜æª”æ¡ˆ
    if (req.file && req.file.path) {
      try {
        fs.unlinkSync(req.file.path);
      } catch (err) {
        // å¿½ç•¥æ¸…ç†éŒ¯èª¤
      }
    }

    res.status(500).json({
      error: 'Failed to upload file to Gemini',
      details: error.message
    });
  }
});

/**
 * å¾ Gemini Files API åˆªé™¤æª”æ¡ˆ
 * DELETE /api/gemini/file/:name
 */
app.delete('/api/gemini/file/:name', async (req, res) => {
  try {
    const fileName = decodeURIComponent(req.params.name);
    console.log(`[Gemini Delete] åˆªé™¤æª”æ¡ˆ: ${fileName}`);

    await ai.files.delete({ name: fileName });

    console.log(`[Gemini Delete] âœ… æª”æ¡ˆå·²åˆªé™¤`);
    res.json({ success: true });

  } catch (error) {
    console.error('[Gemini Delete] Error:', error);
    res.status(500).json({
      error: 'Failed to delete file from Gemini',
      details: error.message
    });
  }
});

/**
 * ä½¿ç”¨ YouTube URL ç”Ÿæˆæ–‡ç« ï¼ˆåƒ…é™å…¬é–‹å½±ç‰‡ï¼‰
 * POST /api/generate-article-url
 * Body: { videoId: string, prompt: string, videoTitle: string, quality?: number }
 */
app.post('/api/generate-article-url', async (req, res) => {
  const { videoId, prompt, videoTitle, quality = 2 } = req.body;

  if (!videoId || !isValidVideoId(videoId)) {
    return res.status(400).json({ error: 'Missing or invalid videoId format' });
  }

  const youtubeUrl = `https://www.youtube.com/watch?v=${videoId}`;
  const outputPath = path.join(DOWNLOAD_DIR, `${videoId}.mp4`);

  try {
    console.log(`\n========== ğŸ“ ä½¿ç”¨ YouTube URL ç”Ÿæˆæ–‡ç«  ==========`);
    console.log(`[Article URL] Video ID: ${videoId}`);
    console.log(`[Article URL] YouTube URL: ${youtubeUrl}`);
    console.log(`[Article URL] Video Title: ${videoTitle}`);

    // æª¢æŸ¥ FFmpeg æ˜¯å¦å®‰è£
    console.log('[Article URL] Checking FFmpeg installation...');
    try {
      const { stdout } = await execAsync('ffmpeg -version');
      const version = stdout.split('\n')[0];
      console.log(`[Article URL] âœ… FFmpeg found: ${version}`);
    } catch (error) {
      console.error('[Article URL] âŒ FFmpeg not found');
      return res.status(500).json({
        error: 'FFmpeg is not installed. Please install it first.',
        details: 'Install FFmpeg: brew install ffmpeg (macOS) or sudo apt install ffmpeg (Ubuntu)'
      });
    }

    const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

    // æ­¥é©Ÿ 1: ä½¿ç”¨ YouTube URL ç”Ÿæˆæ–‡ç« èˆ‡æˆªåœ–æ™‚é–“é»
    console.log('[Article URL] æ­¥é©Ÿ 1/3: ä½¿ç”¨ YouTube URL åˆ†æå½±ç‰‡ä¸¦ç”Ÿæˆæ–‡ç« ...');
    const fullPrompt = generateArticlePrompt(videoTitle, prompt);

    // æ ¹æ“šæœ€ä½³å¯¦è¸ï¼šå½±ç‰‡æ‡‰è©²æ”¾åœ¨ prompt ä¹‹å‰
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: [
        {
          role: 'user',
          parts: [
            { fileData: { fileUri: youtubeUrl } },
            { text: fullPrompt }
          ]
        }
      ],
      config: {
        responseMimeType: "application/json",
      },
    });

    let result;
    try {
      const responseText = response.text;
      console.log(`[Article URL] âœ… Gemini å›æ‡‰é•·åº¦: ${responseText.length} å­—å…ƒ`);
      result = JSON.parse(responseText);

      if (!result.titleA || !result.titleB || !result.titleC || !result.article_text || !result.screenshots) {
        throw new Error('Missing required fields in response');
      }

      console.log(`[Article URL] âœ… æ–‡ç« ç”ŸæˆæˆåŠŸ! æ‰¾åˆ° ${result.screenshots.length} å€‹æˆªåœ–æ™‚é–“é»`);
      console.log(`[Article URL] æ¨™é¡Œ A: ${result.titleA}`);
      console.log(`[Article URL] æˆªåœ–è¦åŠƒå·²ç”Ÿæˆï¼Œç­‰å¾…ä½¿ç”¨è€…æ‰‹å‹•è§¸ç™¼æˆªåœ–`);
    } catch (parseError) {
      console.error('[Article URL] âŒ JSON parsing error:', parseError.message);
      throw new Error(`ç„¡æ³•è§£æ Gemini å›æ‡‰ç‚º JSON æ ¼å¼ã€‚éŒ¯èª¤ï¼š${parseError.message}`);
    }

    console.log(`========== æ–‡ç« ç”Ÿæˆå®Œæˆ ==========\n`);

    res.json({
      success: true,
      titleA: result.titleA,
      titleB: result.titleB,
      titleC: result.titleC,
      article: result.article_text,
      seo_description: result.seo_description,
      image_urls: [],  // ç©ºé™£åˆ—ï¼Œç­‰å¾…ä½¿ç”¨è€…æ‰‹å‹•æˆªåœ–
      screenshots: result.screenshots,  // è¿”å›æˆªåœ–è¦åŠƒ
      videoId,  // è¿”å› videoId ä¾›å¾ŒçºŒæˆªåœ–ä½¿ç”¨
      usedYouTubeUrl: true,
      needsScreenshots: true,  // æ¨™è¨˜æˆªåœ–å·²è¦åŠƒä½†æœªåŸ·è¡Œ
      screenshotsCount: result.screenshots.length
    });

  } catch (error) {
    console.error('Article generation error:', error);

    res.status(500).json({
      error: 'Failed to generate article via YouTube URL',
      details: error.message
    });
  }
});

/**
 * ä½¿ç”¨ YouTube URL ç”Ÿæˆæ–‡ç« ï¼ˆç•°æ­¥ç‰ˆæœ¬ï¼Œé©åˆæ‰‹æ©Ÿç«¯ï¼‰
 * POST /api/generate-article-url-async
 * Body: { videoId: string, prompt: string, videoTitle: string, quality?: number }
 */
app.post('/api/generate-article-url-async', async (req, res) => {
  const { videoId, prompt, videoTitle, quality = 2, uploadedFiles, accessToken, templateId, referenceUrls, referenceVideos } = req.body;

  if (!videoId || !isValidVideoId(videoId)) {
    return res.status(400).json({ error: 'Missing or invalid videoId format' });
  }

  try {
    console.log(`\n========== ğŸ“ [ç•°æ­¥] ä½¿ç”¨ YouTube URL ç”Ÿæˆæ–‡ç«  ==========`);
    console.log(`[Article URL Async] Video ID: ${videoId}`);
    console.log(`[Article URL Async] Video Title: ${videoTitle}`);

    // å‰µå»ºç•°æ­¥ä»»å‹™
    const taskId = taskQueue.createTask('generate-article-url', {
      videoId,
      prompt,
      videoTitle,
      quality,
      uploadedFiles,
      accessToken,
      templateId,
      referenceUrls,
      referenceVideos
    });

    console.log(`[Article URL Async] Task created: ${taskId}`);
    res.json({ taskId });

    // åœ¨èƒŒæ™¯åŸ·è¡Œä»»å‹™
    taskQueue.executeTask(taskId, async (taskId) => {
      const youtubeUrl = `https://www.youtube.com/watch?v=${videoId}`;
      const outputPath = path.join(DOWNLOAD_DIR, `${videoId}.mp4`);

      taskQueue.updateTaskProgress(taskId, 5, 'æ­£åœ¨æª¢æŸ¥ FFmpeg å®‰è£...');
      const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

      // æ­¥é©Ÿ 1: ä½¿ç”¨ YouTube URL ç”Ÿæˆæ–‡ç« èˆ‡æˆªåœ–æ™‚é–“é»
      taskQueue.updateTaskProgress(taskId, 10, 'æ­£åœ¨ä½¿ç”¨ YouTube URL åˆ†æå½±ç‰‡...');

      // ä½¿ç”¨åŒ…å«åƒè€ƒè³‡æ–™çš„ prompt ç”Ÿæˆå™¨
      const fullPrompt = await generateArticlePromptWithReferences(videoTitle, prompt, {
        uploadedFiles,
        referenceUrls,
        referenceVideos
      }, templateId);

      // å»ºç«‹ Gemini API çš„ parts é™£åˆ—
      const parts = [
        { fileData: { fileUri: youtubeUrl } }
      ];

      // åŠ å…¥ä¸Šå‚³çš„åƒè€ƒæª”æ¡ˆ
      if (uploadedFiles && uploadedFiles.length > 0) {
        console.log(`[Article URL Async] åŠ å…¥ ${uploadedFiles.length} å€‹åƒè€ƒæª”æ¡ˆåˆ° Gemini`);
        uploadedFiles.forEach(file => {
          parts.push({ fileData: { fileUri: file.uri } });
        });
      }

      // åŠ å…¥åƒè€ƒå½±ç‰‡
      if (referenceVideos && referenceVideos.length > 0) {
        console.log(`[Article URL Async] åŠ å…¥ ${referenceVideos.length} å€‹åƒè€ƒå½±ç‰‡åˆ° Gemini`);
        referenceVideos.forEach(videoUrl => {
          parts.push({ fileData: { fileUri: videoUrl } });
        });
      }

      // æœ€å¾ŒåŠ å…¥ promptï¼ˆåƒè€ƒç¶²å€æœƒåœ¨ prompt ä¸­æåˆ°ï¼Œé€é urlContext tool è™•ç†ï¼‰
      parts.push({ text: fullPrompt });

      // å»ºç«‹ configï¼ˆå¦‚æœæœ‰åƒè€ƒç¶²å€ï¼Œå•Ÿç”¨ urlContext toolï¼‰
      const config = {
        responseMimeType: "application/json",
      };

      if (referenceUrls && referenceUrls.length > 0) {
        console.log(`[Article URL Async] å•Ÿç”¨ urlContext tool è™•ç† ${referenceUrls.length} å€‹åƒè€ƒç¶²å€`);
        config.tools = [{ urlContext: {} }];
      }

      const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: [
          {
            role: 'user',
            parts
          }
        ],
        config,
      });

      taskQueue.updateTaskProgress(taskId, 30, 'æ­£åœ¨è§£æ Gemini å›æ‡‰...');
      const result = JSON.parse(response.text);

      if (!result.titleA || !result.titleB || !result.titleC || !result.article_text || !result.screenshots) {
        throw new Error('Missing required fields in response');
      }

      console.log(`[Article URL Async] âœ… æ–‡ç« ç”ŸæˆæˆåŠŸ! æ‰¾åˆ° ${result.screenshots.length} å€‹æˆªåœ–æ™‚é–“é»`);
      console.log(`[Article URL Async] æˆªåœ–è¦åŠƒå·²ç”Ÿæˆï¼Œç­‰å¾…ä½¿ç”¨è€…æ‰‹å‹•è§¸ç™¼æˆªåœ–`);

      taskQueue.updateTaskProgress(taskId, 90, 'æ–‡ç« ç”Ÿæˆå®Œæˆ');

      return {
        success: true,
        titleA: result.titleA,
        titleB: result.titleB,
        titleC: result.titleC,
        article: result.article_text,
        seo_description: result.seo_description,
        image_urls: [],  // ç©ºé™£åˆ—ï¼Œç­‰å¾…ä½¿ç”¨è€…æ‰‹å‹•æˆªåœ–
        screenshots: result.screenshots,  // è¿”å›æˆªåœ–è¦åŠƒ
        videoId,  // è¿”å› videoId ä¾›å¾ŒçºŒæˆªåœ–ä½¿ç”¨
        usedYouTubeUrl: true,
        needsScreenshots: true,  // æ¨™è¨˜æˆªåœ–å·²è¦åŠƒä½†æœªåŸ·è¡Œ
        screenshotsCount: result.screenshots.length
      };
    });

  } catch (error) {
    console.error('[Article URL Async] Error:', error);
    res.status(500).json({
      error: 'Failed to create async article generation task',
      details: error.message
    });
  }
});

/**
 * æ‰‹å‹•åŸ·è¡Œæˆªåœ–ï¼ˆä½¿ç”¨è€…è§¸ç™¼ï¼‰
 * POST /api/capture-screenshots
 * Body: { videoId: string, screenshots: array, quality?: number }
 */
app.post('/api/capture-screenshots', async (req, res) => {
  const { videoId, screenshots, quality = 2 } = req.body;

  if (!videoId || !isValidVideoId(videoId)) {
    return res.status(400).json({ error: 'Missing or invalid videoId format' });
  }

  if (!screenshots || !Array.isArray(screenshots)) {
    return res.status(400).json({ error: 'Missing or invalid screenshots array' });
  }

  const youtubeUrl = `https://www.youtube.com/watch?v=${videoId}`;
  const outputPath = path.join(DOWNLOAD_DIR, `${videoId}.mp4`);

  try {
    console.log(`\n========== ğŸ“¸ é–‹å§‹åŸ·è¡Œæˆªåœ– ==========`);
    console.log(`[Capture Screenshots] Video ID: ${videoId}`);
    console.log(`[Capture Screenshots] æˆªåœ–æ•¸é‡: ${screenshots.length}`);
    console.log(`[Capture Screenshots] æˆªåœ–å“è³ª: ${quality}`);

    // æª¢æŸ¥ FFmpeg æ˜¯å¦å®‰è£
    try {
      await execAsync('ffmpeg -version');
    } catch (error) {
      return res.status(500).json({
        error: 'FFmpeg is not installed',
        details: 'Please install FFmpeg first'
      });
    }

    // æª¢æŸ¥å½±ç‰‡æ˜¯å¦å·²ç¶“ä¸‹è¼‰ï¼Œå¦‚æœæ²’æœ‰å‰‡ä¸‹è¼‰
    if (!fs.existsSync(outputPath)) {
      console.log('[Capture Screenshots] å½±ç‰‡å°šæœªä¸‹è¼‰ï¼Œé–‹å§‹ä¸‹è¼‰...');

      let formatSelector;
      if (quality <= 10) {
        formatSelector = '"bestvideo[height<=1080][ext=mp4]+bestaudio[ext=m4a]/bestvideo[height<=1080]+bestaudio/best[height<=1080]/bestvideo[height<=720][ext=mp4]+bestaudio[ext=m4a]/bestvideo[height<=720]+bestaudio/best[height<=720]/best"';
      } else {
        formatSelector = '"bestvideo[height<=720][ext=mp4]+bestaudio[ext=m4a]/bestvideo[height<=720]+bestaudio/best[height<=720]/bestvideo[height<=480][ext=mp4]+bestaudio[ext=m4a]/bestvideo[height<=480]+bestaudio/best[height<=480]/best"';
      }

      const commandParts = [
        'yt-dlp',
        '-f', formatSelector,
        '--merge-output-format', 'mp4',
        '-o', `"${outputPath}"`,
        '--retries', '5',
        '--fragment-retries', '5',
        `"${youtubeUrl}"`,
      ];

      const command = commandParts.join(' ');
      await execAsync(command, { maxBuffer: 10 * 1024 * 1024 });

      if (!fs.existsSync(outputPath)) {
        throw new Error('Video download failed');
      }

      console.log('[Capture Screenshots] âœ… å½±ç‰‡ä¸‹è¼‰å®Œæˆ');
    } else {
      console.log('[Capture Screenshots] ä½¿ç”¨å·²å­˜åœ¨çš„å½±ç‰‡æª”æ¡ˆ');
    }

    // åŸ·è¡Œæˆªåœ–
    console.log('[Capture Screenshots] é–‹å§‹æˆªå–ç•«é¢...');
    const imageUrls = [];

    for (let i = 0; i < screenshots.length; i++) {
      const screenshot = screenshots[i];
      const timestamp = screenshot.timestamp_seconds;
      const currentSeconds = timeToSeconds(timestamp);

      const screenshotGroup = [];
      const offsets = [
        { offset: -2, label: 'before' },
        { offset: 0, label: 'current' },
        { offset: 2, label: 'after' }
      ];

      console.log(`[Capture Screenshots] æˆªåœ–çµ„ ${i + 1}/${screenshots.length} - æ™‚é–“é»: ${timestamp}`);

      for (const { offset, label } of offsets) {
        const targetSeconds = Math.max(0, currentSeconds + offset);
        const targetTime = secondsToTime(targetSeconds);
        const outputFilename = `${videoId}_screenshot_${i}_${label}_${targetTime.replace(':', '-')}.jpg`;
        const screenshotPath = path.join(IMAGES_DIR, outputFilename);

        try {
          await captureScreenshot(outputPath, targetSeconds, screenshotPath, quality);
          screenshotGroup.push(`/images/${outputFilename}`);
          console.log(`[Capture Screenshots] âœ… æˆªåœ–å·²å„²å­˜: ${outputFilename}`);
        } catch (error) {
          console.error(`[Capture Screenshots] âŒ æˆªåœ–å¤±æ•—:`, error.message);
        }
      }

      if (screenshotGroup.length > 0) {
        imageUrls.push(screenshotGroup);
      }
    }

    console.log(`[Capture Screenshots] âœ… æˆªåœ–å®Œæˆï¼Œå…± ${imageUrls.length} çµ„`);
    console.log(`========== æˆªåœ–å®Œæˆ ==========\n`);

    res.json({
      success: true,
      image_urls: imageUrls,
      screenshotsCount: imageUrls.length
    });

  } catch (error) {
    console.error('[Capture Screenshots] Error:', error);
    res.status(500).json({
      error: 'Failed to capture screenshots',
      details: error.message
    });
  }
});

/**
 * å¾ä»»æ„ URL ç”Ÿæˆæ–‡ç« ï¼ˆç•°æ­¥ç‰ˆæœ¬ï¼‰
 * POST /api/generate-article-from-url-async
 * Body: { url: string, prompt: string, uploadedFiles?: any[], templateId?: string, referenceUrls?: string[], referenceVideos?: string[] }
 */
app.post('/api/generate-article-from-url-async', async (req, res) => {
  const { url, prompt, uploadedFiles = [], templateId = 'default', referenceUrls = [], referenceVideos = [] } = req.body;

  if (!url) {
    return res.status(400).json({ error: 'Missing required parameter: url' });
  }

  try {
    console.log(`\n========== ğŸ“ [ç•°æ­¥] å¾ URL ç”Ÿæˆæ–‡ç«  ==========`);
    console.log(`[Article URL-Only Async] URL: ${url}`);

    // å‰µå»ºç•°æ­¥ä»»å‹™
    const taskId = taskQueue.createTask('generate-article-from-url', {
      url,
      prompt,
      uploadedFiles,
      templateId,
      referenceUrls,
      referenceVideos
    });

    console.log(`[Article URL-Only Async] Task created: ${taskId}`);
    res.json({ taskId });

    // åœ¨èƒŒæ™¯åŸ·è¡Œä»»å‹™
    taskQueue.executeTask(taskId, async (taskId) => {
      taskQueue.updateTaskProgress(taskId, 10, 'æ­£åœ¨åˆå§‹åŒ– Gemini AI...');
      const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

      taskQueue.updateTaskProgress(taskId, 30, 'æ­£åœ¨å¾ URL ç²å–å…§å®¹...');

      // ä½¿ç”¨åŒ…å«åƒè€ƒè³‡æ–™çš„ prompt ç”Ÿæˆå™¨
      const fullPrompt = await generateArticlePromptWithReferences(url, prompt, {
        uploadedFiles,
        referenceUrls,
        referenceVideos
      }, templateId);

      taskQueue.updateTaskProgress(taskId, 50, 'æ­£åœ¨ä½¿ç”¨ Gemini AI åˆ†æå…§å®¹ä¸¦ç”Ÿæˆæ–‡ç« ...');

      // å»ºç«‹ Gemini API çš„ parts é™£åˆ—
      const parts = [
        { fileData: { fileUri: url } }
      ];

      // åŠ å…¥ä¸Šå‚³çš„åƒè€ƒæª”æ¡ˆ
      if (uploadedFiles && uploadedFiles.length > 0) {
        console.log(`[Article URL-Only Async] åŠ å…¥ ${uploadedFiles.length} å€‹åƒè€ƒæª”æ¡ˆåˆ° Gemini`);
        uploadedFiles.forEach(file => {
          parts.push({ fileData: { fileUri: file.uri } });
        });
      }

      // åŠ å…¥åƒè€ƒå½±ç‰‡
      if (referenceVideos && referenceVideos.length > 0) {
        console.log(`[Article URL-Only Async] åŠ å…¥ ${referenceVideos.length} å€‹åƒè€ƒå½±ç‰‡åˆ° Gemini`);
        referenceVideos.forEach(videoUrl => {
          parts.push({ fileData: { fileUri: videoUrl } });
        });
      }

      // æœ€å¾ŒåŠ å…¥ promptï¼ˆåƒè€ƒç¶²å€æœƒåœ¨ prompt ä¸­æåˆ°ï¼Œé€é urlContext tool è™•ç†ï¼‰
      parts.push({ text: fullPrompt });

      // å»ºç«‹ configï¼ˆå¦‚æœæœ‰åƒè€ƒç¶²å€ï¼Œå•Ÿç”¨ urlContext toolï¼‰
      const config = {
        responseMimeType: "application/json",
        maxOutputTokens: 8192,
      };

      if (referenceUrls && referenceUrls.length > 0) {
        console.log(`[Article URL-Only Async] å•Ÿç”¨ urlContext tool è™•ç† ${referenceUrls.length} å€‹åƒè€ƒç¶²å€`);
        config.tools = [{ urlContext: {} }];
      }

      // ä½¿ç”¨ Gemini åˆ†æ URL
      const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: [
          {
            role: 'user',
            parts
          }
        ],
        config,
      });

      taskQueue.updateTaskProgress(taskId, 90, 'æ­£åœ¨è§£æ Gemini å›æ‡‰...');
      const result = JSON.parse(response.text);

      console.log(`[Article URL-Only Async] âœ… æ–‡ç« ç”Ÿæˆå®Œæˆ: ${result.titleA}`);

      return {
        success: true,
        titleA: result.titleA,
        titleB: result.titleB,
        titleC: result.titleC,
        article: result.article_text,
        seo_description: result.seo_description,
        image_urls: [],
        screenshots: []
      };
    });

  } catch (error) {
    console.error('[Article URL-Only Async] Error:', error);
    res.status(500).json({
      error: 'Failed to create async article generation task from URL',
      details: error.message
    });
  }
});

/**
 * ç”Ÿæˆæ–‡ç« èˆ‡æˆªåœ–ï¼ˆç”¨æ–¼éå…¬é–‹å½±ç‰‡ï¼‰
 * POST /api/generate-article
 * Body: { videoId: string, filePath: string, prompt: string, videoTitle: string, quality?: number }
 * æ³¨æ„ï¼šfilePath æ˜¯å¿…éœ€çš„ï¼Œå› ç‚ºéœ€è¦æœ¬åœ°æª”æ¡ˆä¾†æˆªåœ–
 */
app.post('/api/generate-article', async (req, res) => {
  const { videoId, filePath, prompt, videoTitle, quality = 2, uploadedFiles = [], templateId = 'default', referenceUrls = [], referenceVideos = [] } = req.body;

  if (!videoId || !isValidVideoId(videoId)) {
    return res.status(400).json({ error: 'Missing or invalid videoId format' });
  }

  if (!filePath) {
    return res.status(400).json({ error: 'Missing required parameter: filePath' });
  }

  try {
    console.log(`\n========== ğŸ“ é–‹å§‹ç”Ÿæˆæ–‡ç«  ==========`);
    console.log(`[Article] Video ID: ${videoId}`);
    console.log(`[Article] File Path: ${filePath}`);
    console.log(`[Article] Video Title: ${videoTitle}`);
    if (uploadedFiles.length > 0) {
      console.log(`[Article] åƒè€ƒæª”æ¡ˆ: ${uploadedFiles.length} å€‹`);
    }
    if (referenceUrls.length > 0) {
      console.log(`[Article] åƒè€ƒç¶²å€: ${referenceUrls.length} å€‹`);
    }
    if (referenceVideos.length > 0) {
      console.log(`[Article] åƒè€ƒå½±ç‰‡: ${referenceVideos.length} å€‹`);
    }

    // æª¢æŸ¥ FFmpeg æ˜¯å¦å®‰è£
    console.log('[Article] Checking FFmpeg installation...');
    try {
      const { stdout } = await execAsync('ffmpeg -version');
      const version = stdout.split('\n')[0];
      console.log(`[Article] âœ… FFmpeg found: ${version}`);
    } catch (error) {
      console.error('[Article] âŒ FFmpeg not found');
      return res.status(500).json({
        error: 'FFmpeg is not installed. Please install it first.',
        details: 'Install FFmpeg: brew install ffmpeg (macOS) or sudo apt install ffmpeg (Ubuntu)'
      });
    }

    const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

    // å…ˆæª¢æŸ¥æª”æ¡ˆæ˜¯å¦å·²å­˜åœ¨æ–¼ Files API
    console.log('[Article] æ­¥é©Ÿ 2/5: æª¢æŸ¥ Files API ä¸­æ˜¯å¦å·²æœ‰æ­¤æª”æ¡ˆ...');
    const existingFile = await findFileByDisplayName(ai, videoId);

    let uploadedFile;
    let reusedFile = false;

    if (existingFile) {
      console.log(`[Article] âœ… æ‰¾åˆ°å·²å­˜åœ¨çš„æª”æ¡ˆï¼Œå°‡é‡è¤‡ä½¿ç”¨ï¼`);
      console.log(`[Article] File Name: ${existingFile.name}`);
      console.log(`[Article] Display Name: ${existingFile.displayName}`);
      console.log(`[Article] File URI: ${existingFile.uri}`);
      console.log(`[Article] è·³éä¸Šå‚³æ­¥é©Ÿï¼Œç¯€çœæ™‚é–“å’Œæµé‡ï¼`);
      console.log(`[Article] æœ¬åœ°æª”æ¡ˆä¿ç•™ç”¨æ–¼ FFmpeg æˆªåœ–`);
      uploadedFile = existingFile;
      reusedFile = true;
    } else {
      console.log('[Article] æª”æ¡ˆä¸å­˜åœ¨æ–¼ Files APIï¼Œéœ€è¦ä¸Šå‚³...');
      console.log('[Article] æ­¥é©Ÿ 3/5: æ­£åœ¨ä¸Šå‚³å½±ç‰‡åˆ° Gemini...');

      // ä¸Šå‚³å½±ç‰‡åˆ° Geminiï¼ˆä½¿ç”¨ videoId ä½œç‚º displayNameï¼‰
      uploadedFile = await ai.files.upload({
        file: filePath,
        config: {
          mimeType: 'video/mp4',
          displayName: videoId  // ä½¿ç”¨ videoId ä½œç‚ºæª”æ¡ˆåç¨±ï¼Œæ–¹ä¾¿å¾ŒçºŒæŸ¥æ‰¾
        },
      });

      console.log(`[Article] âœ… æª”æ¡ˆå·²ä¸Šå‚³`);
      console.log(`[Article] File Name (ç³»çµ±ç”Ÿæˆ): ${uploadedFile.name}`);
      console.log(`[Article] Display Name (æˆ‘å€‘è¨­å®š): ${uploadedFile.displayName}`);
      console.log(`[Article] File URI: ${uploadedFile.uri}`);
      console.log(`[Article] File State: ${uploadedFile.state}`);
    }

    // ç­‰å¾…æª”æ¡ˆè™•ç†å®Œæˆï¼ˆæ–°ä¸Šå‚³æˆ–é‡ç”¨ä¸­çš„ PROCESSING æª”æ¡ˆï¼‰
    if (uploadedFile.state === 'PROCESSING') {
        console.log('[Article] â³ Gemini æ­£åœ¨è™•ç†å½±ç‰‡,ç­‰å¾…è™•ç†å®Œæˆ...');
        let attempts = 0;
        const maxAttempts = 60;
        let isActive = false;

        while (!isActive && attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 5000));
          try {
            const fetchedFile = await ai.files.get({ name: uploadedFile.name });
            if (fetchedFile) {
              const progress = Math.round(((attempts + 1) / maxAttempts) * 100);
              console.log(`[Article] æª¢æŸ¥ç‹€æ…‹ ${attempts + 1}/${maxAttempts} (${progress}%) - State: ${fetchedFile.state}`);
              if (fetchedFile.state === 'ACTIVE') {
                isActive = true;
                console.log('[Article] âœ… æª”æ¡ˆè™•ç†å®Œæˆ,å¯ä»¥é–‹å§‹ç”Ÿæˆæ–‡ç« !');
              } else if (fetchedFile.state === 'FAILED') {
                throw new Error('File processing failed');
              }
            }
          } catch (error) {
            console.log(`[Article] âš ï¸  æª¢æŸ¥ ${attempts + 1}/${maxAttempts} æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message}`);
          }
          attempts++;
        }

        if (!isActive) {
          throw new Error('File processing timeout. Please try again later.');
        }
      } else if (uploadedFile.state === 'ACTIVE') {
        console.log('[Article] âœ… æª”æ¡ˆå·²ç¶“æ˜¯ ACTIVE ç‹€æ…‹');
      } else {
        throw new Error(`Unexpected file state: ${uploadedFile.state}`);
      }

    // ç”Ÿæˆæ–‡ç« æç¤ºè©
    console.log(reusedFile ? '[Article] æ­¥é©Ÿ 3/5: æ­£åœ¨ç”Ÿæˆæ–‡ç« å…§å®¹èˆ‡æˆªåœ–æ™‚é–“é»...' : '[Article] æ­¥é©Ÿ 4/5: æ­£åœ¨ç”Ÿæˆæ–‡ç« å…§å®¹èˆ‡æˆªåœ–æ™‚é–“é»...');

    // ä½¿ç”¨åŒ…å«åƒè€ƒè³‡æ–™çš„ prompt ç”Ÿæˆå™¨
    const fullPrompt = await generateArticlePromptWithReferences(videoTitle, prompt, {
      uploadedFiles,
      referenceUrls,
      referenceVideos
    }, templateId);

    // å»ºç«‹ Gemini API çš„ parts é™£åˆ—
    const parts = [
      { fileData: { fileUri: uploadedFile.uri, mimeType: 'video/mp4' } }
    ];

    // åŠ å…¥ä¸Šå‚³çš„åƒè€ƒæª”æ¡ˆ
    if (uploadedFiles && uploadedFiles.length > 0) {
      console.log(`[Article] åŠ å…¥ ${uploadedFiles.length} å€‹åƒè€ƒæª”æ¡ˆåˆ° Gemini`);
      uploadedFiles.forEach(file => {
        parts.push({ fileData: { fileUri: file.uri } });
      });
    }

    // åŠ å…¥åƒè€ƒå½±ç‰‡
    if (referenceVideos && referenceVideos.length > 0) {
      console.log(`[Article] åŠ å…¥ ${referenceVideos.length} å€‹åƒè€ƒå½±ç‰‡åˆ° Gemini`);
      referenceVideos.forEach(videoUrl => {
        parts.push({ fileData: { fileUri: videoUrl } });
      });
    }

    // æœ€å¾ŒåŠ å…¥ promptï¼ˆåƒè€ƒç¶²å€æœƒåœ¨ prompt ä¸­æåˆ°ï¼Œé€é urlContext tool è™•ç†ï¼‰
    parts.push({ text: fullPrompt });

    // å»ºç«‹ configï¼ˆå¦‚æœæœ‰åƒè€ƒç¶²å€ï¼Œå•Ÿç”¨ urlContext toolï¼‰
    const config = {
      responseMimeType: "application/json",
    };

    if (referenceUrls && referenceUrls.length > 0) {
      console.log(`[Article] å•Ÿç”¨ urlContext tool è™•ç† ${referenceUrls.length} å€‹åƒè€ƒç¶²å€`);
      config.tools = [{ urlContext: {} }];
    }

    // å‘¼å« Gemini API ç”Ÿæˆæ–‡ç« èˆ‡æˆªåœ–æ™‚é–“é»
    // æ ¹æ“šæœ€ä½³å¯¦è¸ï¼šå½±ç‰‡æ‡‰è©²æ”¾åœ¨ prompt ä¹‹å‰
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: [
        {
          role: 'user',
          parts
        }
      ],
      config,
    });

    let result;
    try {
      const responseText = response.text;
      console.log(`[Article] âœ… Gemini å›æ‡‰é•·åº¦: ${responseText.length} å­—å…ƒ`);
      console.log(`[Article] å›æ‡‰é è¦½: ${responseText.substring(0, 150)}...`);

      result = JSON.parse(responseText);

      // é©—è­‰å¿…è¦æ¬„ä½
      if (!result.titleA || !result.titleB || !result.titleC || !result.article_text || !result.screenshots) {
        throw new Error('Missing required fields in response');
      }

      console.log(`[Article] âœ… æ–‡ç« ç”ŸæˆæˆåŠŸ! æ‰¾åˆ° ${result.screenshots.length} å€‹æˆªåœ–æ™‚é–“é»`);
      console.log(`[Article] æ¨™é¡Œ A: ${result.titleA}`);
    } catch (parseError) {
      console.error('[Article] âŒ JSON parsing error:', parseError.message);
      console.error('[Article] Full response text:', response.text);

      // å˜—è©¦æ‰¾å‡ºå•é¡Œä½ç½®
      const lines = response.text.split('\n');
      console.error(`[Article] Response has ${lines.length} lines`);

      throw new Error(`ç„¡æ³•è§£æ Gemini å›æ‡‰ç‚º JSON æ ¼å¼ã€‚éŒ¯èª¤ï¼š${parseError.message}`);
    }

    // ä½¿ç”¨ FFmpeg æˆªå–ç•«é¢
    // æ¯å€‹æ™‚é–“é»æˆªå– 3 å¼µåœ–ç‰‡ï¼šå‰ 2 ç§’ã€ç•¶å‰ã€å¾Œ 2 ç§’
    console.log(reusedFile ? '[Article] æ­¥é©Ÿ 4/5: æ­£åœ¨æˆªå–é—œéµç•«é¢...' : '[Article] æ­¥é©Ÿ 5/5: æ­£åœ¨æˆªå–é—œéµç•«é¢...');
    console.log(`[Article] æˆªåœ–å“è³ªè¨­å®š: ${quality} (2=æœ€é«˜, 31=æœ€ä½)`);

    const imageUrls = [];
    for (let i = 0; i < result.screenshots.length; i++) {
      const screenshot = result.screenshots[i];
      const timestamp = screenshot.timestamp_seconds; // æ ¼å¼ï¼šmm:ss
      const currentSeconds = timeToSeconds(timestamp);

      const screenshotGroup = [];
      const offsets = [
        { offset: -2, label: 'before' },
        { offset: 0, label: 'current' },
        { offset: 2, label: 'after' }
      ];

      console.log(`[Article] æˆªåœ–çµ„ ${i + 1}/${result.screenshots.length} - æ™‚é–“é»: ${timestamp} - åŸå› : ${screenshot.reason_for_screenshot}`);

      for (const { offset, label } of offsets) {
        const targetSeconds = Math.max(0, currentSeconds + offset); // ç¢ºä¿ä¸æœƒå°æ–¼ 0
        const targetTime = secondsToTime(targetSeconds); // åƒ…ç”¨æ–¼æª”å
        const outputFilename = `${videoId}_screenshot_${i}_${label}_${targetTime.replace(':', '-')}.jpg`;
        const outputPath = path.join(IMAGES_DIR, outputFilename);

        try {
          await captureScreenshot(filePath, targetSeconds, outputPath, quality);
          screenshotGroup.push(`/images/${outputFilename}`);
          console.log(`[Article] âœ… æˆªåœ–å·²å„²å­˜: ${outputFilename} (${label}: ${targetSeconds}s)`);
        } catch (error) {
          console.error(`[Article] âŒ æˆªåœ–å¤±æ•— (æ™‚é–“é» ${targetSeconds}s, ${label}):`, error.message);
          // å¦‚æœæŸå¼µæˆªåœ–å¤±æ•—ï¼Œä»ç„¶ç¹¼çºŒè™•ç†å…¶ä»–æˆªåœ–
        }
      }

      if (screenshotGroup.length > 0) {
        imageUrls.push(screenshotGroup);
      }
    }

    // ä¿ç•™æš«å­˜å½±ç‰‡æª”æ¡ˆä¾›å¾ŒçºŒé‡æ–°æˆªåœ–ä½¿ç”¨
    console.log(`[Article] âœ… å·²å®Œæˆæˆªåœ–ï¼Œæš«å­˜æª”æ¡ˆä¿ç•™ä¾›å¾ŒçºŒä½¿ç”¨: ${filePath}`);
    console.log(`========== æ–‡ç« ç”Ÿæˆå®Œæˆ ==========\n`);

    res.json({
      success: true,
      titleA: result.titleA,
      titleB: result.titleB,
      titleC: result.titleC,
      article: result.article_text,
      seo_description: result.seo_description,
      image_urls: imageUrls,
      screenshots: result.screenshots,
      geminiFileName: uploadedFile.name,
      geminiFileUri: uploadedFile.uri
    });

  } catch (error) {
    console.error('Article generation error:', error);

    res.status(500).json({
      error: 'Failed to generate article',
      details: error.message
    });
  }
});

/**
 * ä½¿ç”¨ç¾æœ‰ Gemini æª”æ¡ˆé‡æ–°ç”Ÿæˆæ–‡ç« 
 * POST /api/regenerate-article
 * Body: { videoId: string, geminiFileName: string, prompt: string, videoTitle: string }
 */
app.post('/api/regenerate-article', async (req, res) => {
  const { videoId, geminiFileName, prompt, videoTitle } = req.body;

  if (!videoId || !isValidVideoId(videoId)) {
    return res.status(400).json({ error: 'Missing or invalid videoId format' });
  }

  if (!geminiFileName) {
    return res.status(400).json({ error: 'Missing required parameter: geminiFileName' });
  }

  try {
    console.log(`Regenerating article using existing file: ${geminiFileName}`);

    const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

    // æª¢æŸ¥æª”æ¡ˆæ˜¯å¦å­˜åœ¨
    let fileInfo;
    try {
      fileInfo = await ai.files.get({ name: geminiFileName });
    } catch (error) {
      console.log(`File not found: ${error.message}`);
      return res.status(404).json({
        error: 'File not found in Gemini',
        needsRedownload: true
      });
    }

    if (fileInfo.state !== 'ACTIVE') {
      return res.status(400).json({
        error: 'File is not ready',
        state: fileInfo.state
      });
    }

    console.log(`âœ… File found and active: ${fileInfo.uri}`);

    // ç”Ÿæˆæ–‡ç« æç¤ºè©
    const fullPrompt = generateArticlePrompt(videoTitle, prompt);

    // å‘¼å« Gemini API
    // æ ¹æ“šæœ€ä½³å¯¦è¸ï¼šå½±ç‰‡æ‡‰è©²æ”¾åœ¨ prompt ä¹‹å‰
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: [
        {
          role: 'user',
          parts: [
            { fileData: { fileUri: fileInfo.uri, mimeType: 'video/mp4' } },
            { text: fullPrompt }
          ]
        }
      ],
      config: {
        responseMimeType: "application/json",
        maxOutputTokens: 8192,  // è¨­å®šè¼ƒé«˜çš„ token ä¸Šé™ï¼Œé¿å…ç”Ÿæˆçµæœè¢«æˆªæ–·
      },
    });

    let result;
    try {
      const responseText = response.text;
      console.log('Response length:', responseText.length);
      console.log('Response preview:', responseText.substring(0, 200));

      result = JSON.parse(responseText);

      // é©—è­‰å¿…è¦æ¬„ä½
      if (!result.titleA || !result.titleB || !result.titleC || !result.article_text || !result.screenshots) {
        throw new Error('Missing required fields in response');
      }

      console.log(`Article regenerated successfully. Found ${result.screenshots.length} screenshots.`);
    } catch (parseError) {
      console.error('âŒ JSON parsing error:', parseError.message);
      console.error('Full response text:', response.text);

      throw new Error(`ç„¡æ³•è§£æ Gemini å›æ‡‰ç‚º JSON æ ¼å¼ã€‚éŒ¯èª¤ï¼š${parseError.message}`);
    }

    // æ³¨æ„ï¼šé‡æ–°ç”Ÿæˆæ™‚ç„¡æ³•æˆªåœ–ï¼ˆå› ç‚ºæ²’æœ‰æœ¬åœ°å½±ç‰‡æª”æ¡ˆï¼‰
    // éœ€è¦ä½¿ç”¨è€…é‡æ–°ä¸‹è¼‰å½±ç‰‡æ‰èƒ½æˆªåœ–
    res.json({
      success: true,
      titleA: result.titleA,
      titleB: result.titleB,
      titleC: result.titleC,
      article: result.article_text,
      seo_description: result.seo_description,
      screenshots: result.screenshots,
      geminiFileName: fileInfo.name,
      geminiFileUri: fileInfo.uri,
      reusedExistingFile: true,
      note: 'Screenshots not captured. Please re-download video to generate screenshots.'
    });

  } catch (error) {
    console.error('Article regeneration error:', error);
    res.status(500).json({
      error: 'Failed to regenerate article',
      details: error.message
    });
  }
});

/**
 * é‡æ–°ç”Ÿæˆæˆªåœ–ï¼ˆè®“ Gemini é‡æ–°çœ‹å½±ç‰‡ä¸¦æä¾›æ–°çš„æˆªåœ–å»ºè­°ï¼‰
 * POST /api/regenerate-screenshots
 * Body: { videoId: string, videoTitle: string, filePath: string, prompt?: string, quality?: number }
 */
app.post('/api/regenerate-screenshots', async (req, res) => {
  const { videoId, videoTitle, filePath, prompt, quality = 2 } = req.body;

  if (!videoId || !isValidVideoId(videoId)) {
    return res.status(400).json({ error: 'Missing or invalid videoId format' });
  }

  if (!videoTitle || !filePath) {
    return res.status(400).json({ error: 'Missing required parameters: videoTitle, filePath' });
  }

  try {
    console.log(`\n========== ğŸ”„ é‡æ–°ç”Ÿæˆæˆªåœ– ==========`);
    console.log(`[Regenerate Screenshots] Video ID: ${videoId}`);
    console.log(`[Regenerate Screenshots] File Path: ${filePath}`);
    console.log(`[Regenerate Screenshots] Video Title: ${videoTitle}`);

    const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

    // æ­¥é©Ÿ 1: æª¢æŸ¥ Files API ä¸­æ˜¯å¦æœ‰æ­¤æª”æ¡ˆ
    console.log('[Regenerate Screenshots] æ­¥é©Ÿ 1/4: æª¢æŸ¥ Files API ä¸­æ˜¯å¦å·²æœ‰æ­¤æª”æ¡ˆ...');
    const filesList = await ai.files.list();
    const files = filesList.pageInternal || [];
    const existingFile = files.find(file =>
      file.displayName === videoId && file.state === 'ACTIVE'
    );

    if (!existingFile) {
      return res.status(404).json({ error: 'Video file not found in Files API. Please generate article first.' });
    }

    console.log(`[Regenerate Screenshots] âœ… æ‰¾åˆ°å·²å­˜åœ¨çš„æª”æ¡ˆ: ${existingFile.uri}`);

    // æ­¥é©Ÿ 2: è®“ Gemini é‡æ–°çœ‹å½±ç‰‡ä¸¦ç”Ÿæˆæ–°çš„æˆªåœ–å»ºè­°
    console.log('[Regenerate Screenshots] æ­¥é©Ÿ 2/4: è®“ Gemini é‡æ–°åˆ†æå½±ç‰‡ä¸¦æä¾›æ–°çš„æˆªåœ–å»ºè­°...');
    const fullPrompt = generateArticlePrompt(videoTitle, prompt || '');

    // æ ¹æ“šæœ€ä½³å¯¦è¸ï¼šå½±ç‰‡æ‡‰è©²æ”¾åœ¨ prompt ä¹‹å‰
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: [
        {
          role: 'user',
          parts: [
            { fileData: { fileUri: existingFile.uri, mimeType: 'video/mp4' } },
            { text: fullPrompt }
          ]
        }
      ],
      config: {
        responseMimeType: "application/json",
      },
    });

    let result;
    try {
      const responseText = response.text;
      result = JSON.parse(responseText);
    } catch (parseError) {
      console.error('[Regenerate Screenshots] âŒ JSON parsing error:', parseError.message);
      throw new Error(`ç„¡æ³•è§£æ Gemini å›æ‡‰ç‚º JSON æ ¼å¼ã€‚éŒ¯èª¤ï¼š${parseError.message}`);
    }

    // æ­¥é©Ÿ 3: ä½¿ç”¨æœ¬åœ°å½±ç‰‡é€²è¡Œæˆªåœ–
    console.log('[Regenerate Screenshots] æ­¥é©Ÿ 3/4: æ­£åœ¨æˆªå–æ–°çš„é—œéµç•«é¢...');
    console.log(`[Regenerate Screenshots] æˆªåœ–å“è³ªè¨­å®š: ${quality} (2=æœ€é«˜, 31=æœ€ä½)`);

    const imageUrls = [];
    for (let i = 0; i < result.screenshots.length; i++) {
      const screenshot = result.screenshots[i];
      const timestamp = screenshot.timestamp_seconds;
      const currentSeconds = timeToSeconds(timestamp);

      const screenshotGroup = [];
      const offsets = [
        { offset: -2, label: 'before' },
        { offset: 0, label: 'current' },
        { offset: 2, label: 'after' }
      ];

      console.log(`[Regenerate Screenshots] æˆªåœ–çµ„ ${i + 1}/${result.screenshots.length} - æ™‚é–“é»: ${timestamp} - åŸå› : ${screenshot.reason_for_screenshot}`);

      for (const { offset, label } of offsets) {
        const targetSeconds = Math.max(0, currentSeconds + offset);
        const targetTime = secondsToTime(targetSeconds); // åƒ…ç”¨æ–¼æª”å

        const outputFilename = `${videoId}_screenshot_${i}_${label}_${targetTime.replace(':', '-')}.jpg`;
        const outputPath = path.join(IMAGES_DIR, outputFilename);

        try {
          await captureScreenshot(filePath, targetSeconds, outputPath, quality);
          screenshotGroup.push(`/images/${outputFilename}`);
          console.log(`[Regenerate Screenshots] âœ… æˆªåœ–å·²å„²å­˜: ${outputFilename} (${label}: ${targetSeconds}s)`);
        } catch (error) {
          console.error(`[Regenerate Screenshots] âŒ æˆªåœ–å¤±æ•— (æ™‚é–“é» ${targetSeconds}s, ${label}):`, error.message);
        }
      }

      if (screenshotGroup.length > 0) {
        imageUrls.push(screenshotGroup);
      }
    }

    // æ­¥é©Ÿ 4: å®Œæˆï¼ˆä¿ç•™æš«å­˜æª”æ¡ˆä¾›å¾ŒçºŒä½¿ç”¨ï¼‰
    console.log(`[Regenerate Screenshots] âœ… å·²å®Œæˆæˆªåœ–ï¼Œæš«å­˜æª”æ¡ˆä¿ç•™: ${filePath}`);
    console.log(`========== é‡æ–°æˆªåœ–å®Œæˆ ==========\n`);

    res.json({
      success: true,
      titleA: result.titleA,
      titleB: result.titleB,
      titleC: result.titleC,
      article: result.article_text,
      seo_description: result.seo_description,
      image_urls: imageUrls,
      screenshots: result.screenshots,
    });

  } catch (error) {
    console.error('Regenerate screenshots error:', error);

    res.status(500).json({
      error: 'Failed to regenerate screenshots',
      details: error.message
    });
  }
});

/**
 * æª¢æŸ¥ Files API ä¸­æ˜¯å¦å­˜åœ¨æŒ‡å®š videoId çš„æª”æ¡ˆ
 * GET /api/check-file/:videoId
 */
app.get('/api/check-file/:videoId', async (req, res) => {
  const { videoId } = req.params;

  if (!videoId || !isValidVideoId(videoId)) {
    return res.status(400).json({ error: 'Invalid videoId format' });
  }

  try {
    console.log(`[Check File] Checking if file exists for videoId: ${videoId}`);
    const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });

    // åˆ—å‡ºæ‰€æœ‰æª”æ¡ˆï¼Œå°‹æ‰¾ç¬¦åˆ displayName çš„æª”æ¡ˆ
    console.log(`[Check File] Calling ai.files.list()...`);
    const matchingFile = await findFileByDisplayName(ai, videoId);

    if (matchingFile) {
      console.log(`[Check File] âœ… Found file: ${matchingFile.name}, State: ${matchingFile.state}`);

      // æª¢æŸ¥æª”æ¡ˆç‹€æ…‹
      if (matchingFile.state === 'ACTIVE') {
        return res.json({
          exists: true,
          file: {
            name: matchingFile.name,
            uri: matchingFile.uri,
            state: matchingFile.state,
            displayName: matchingFile.displayName,
            createTime: matchingFile.createTime,
            expirationTime: matchingFile.expirationTime
          }
        });
      } else if (matchingFile.state === 'PROCESSING') {
        return res.json({
          exists: true,
          processing: true,
          file: {
            name: matchingFile.name,
            state: matchingFile.state,
            displayName: matchingFile.displayName
          }
        });
      } else {
        // æª”æ¡ˆå­˜åœ¨ä½†ç‹€æ…‹ä¸æ˜¯ ACTIVE æˆ– PROCESSINGï¼ˆå¯èƒ½æ˜¯ FAILEDï¼‰
        return res.json({
          exists: false,
          reason: `File exists but state is ${matchingFile.state}`
        });
      }
    }

    console.log(`[Check File] âŒ No file found for videoId: ${videoId}`);
    res.json({ exists: false });

  } catch (error) {
    console.error('[Check File] Error:', error);
    res.status(500).json({
      error: 'Failed to check file',
      details: error.message
    });
  }
});

/**
 * æ¸…ç†æš«å­˜æª”æ¡ˆ
 * DELETE /api/cleanup/:videoId
 */
app.delete('/api/cleanup/:videoId', (req, res) => {
  const { videoId } = req.params;

  if (!videoId || !isValidVideoId(videoId)) {
    return res.status(400).json({ error: 'Invalid videoId format' });
  }

  const filePath = path.join(DOWNLOAD_DIR, `${videoId}.mp4`);

  try {
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
      console.log(`Cleaned up: ${filePath}`);
    }
    res.json({ success: true });
  } catch (error) {
    console.error('Cleanup error:', error);
    res.status(500).json({ error: 'Cleanup failed' });
  }
});

// ==================== AI é »é“åˆ†æ API ====================

/**
 * ç²å–å¯ç”¨çš„ AI æ¨¡å‹åˆ—è¡¨
 * GET /api/ai-models/available
 */
app.get('/api/ai-models/available', async (req, res) => {
  try {
    const models = aiManager.getAvailableModels();

    res.json({
      success: true,
      models,
      count: models.length,
    });
  } catch (error) {
    console.error('[AI Models] ç²å–æ¨¡å‹åˆ—è¡¨å¤±æ•—:', error);
    res.status(500).json({
      success: false,
      error: 'ç²å–æ¨¡å‹åˆ—è¡¨å¤±æ•—',
      details: error.message,
    });
  }
});

/**
 * æª¢æŸ¥ç‰¹å®šæ¨¡å‹ç‹€æ…‹
 * GET /api/ai-models/:modelId/status
 */
app.get('/api/ai-models/:modelId/status', async (req, res) => {
  try {
    const { modelId } = req.params;
    const status = await aiManager.getModelStatus(modelId);

    res.json({
      success: true,
      modelId,
      status,
    });
  } catch (error) {
    console.error('[AI Models] æª¢æŸ¥æ¨¡å‹ç‹€æ…‹å¤±æ•—:', error);
    res.status(500).json({
      success: false,
      error: 'æª¢æŸ¥æ¨¡å‹ç‹€æ…‹å¤±æ•—',
      details: error.message,
    });
  }
});

/**
 * ç²å–æ¨è–¦æ¨¡å‹
 * GET /api/ai-models/recommend?analysisType=subscriber-growth
 */
app.get('/api/ai-models/recommend', (req, res) => {
  try {
    const { analysisType } = req.query;

    if (!analysisType) {
      return res.status(400).json({
        success: false,
        error: 'ç¼ºå°‘ analysisType åƒæ•¸',
      });
    }

    const recommendedModel = aiManager.getRecommendedModel(analysisType);

    if (!recommendedModel) {
      return res.status(404).json({
        success: false,
        error: 'æ²’æœ‰å¯ç”¨çš„æ¨è–¦æ¨¡å‹',
        suggestion: 'è«‹æª¢æŸ¥ API Key é…ç½®',
      });
    }

    res.json({
      success: true,
      analysisType,
      recommendedModel,
    });
  } catch (error) {
    console.error('[AI Models] ç²å–æ¨è–¦æ¨¡å‹å¤±æ•—:', error);
    res.status(500).json({
      success: false,
      error: 'ç²å–æ¨è–¦æ¨¡å‹å¤±æ•—',
      details: error.message,
    });
  }
});

/**
 * AI é »é“åˆ†æï¼ˆæ”¯æ´å¤šæ¨¡å‹ã€å¤šåˆ†æé¡å‹ï¼‰
 * POST /api/analyze-channel
 */
app.post('/api/analyze-channel', async (req, res) => {
  const {
    startDate,
    endDate,
    channelId,
    videos,
    channelStats,
    analytics,
    modelType = 'gemini-2.5-flash', // é»˜èªä½¿ç”¨ Gemini Flash
    analysisType = 'comprehensive', // é»˜èªä½¿ç”¨ç¶œåˆåˆ†æ
  } = req.body;

  // é©—è­‰è¼¸å…¥
  if (!startDate || !endDate) {
    return res.status(400).json({ error: 'Missing startDate or endDate' });
  }

  if (!videos || !Array.isArray(videos)) {
    return res.status(400).json({ error: 'Missing or invalid videos array' });
  }

  try {
    console.log(`\n========== ğŸ“Š é–‹å§‹åˆ†æé »é“è¡¨ç¾ ==========`);
    console.log(`[Channel Analysis] æ¨¡å‹: ${modelType}`);
    console.log(`[Channel Analysis] åˆ†æé¡å‹: ${analysisType}`);
    console.log(`[Channel Analysis] æ—¥æœŸç¯„åœ: ${startDate} ~ ${endDate}`);
    console.log(`[Channel Analysis] å½±ç‰‡æ•¸é‡: ${videos.length}`);

    // ç”Ÿæˆåˆ†æ Prompt
    const prompt = PromptTemplates.generatePrompt({
      type: analysisType,
      dateRange: { startDate, endDate },
      channelStats,
      videos,
      analytics,
    });

    console.log('[Channel Analysis] ğŸ“¤ ç™¼é€è«‹æ±‚åˆ° AI æ¨¡å‹...');

    // ä½¿ç”¨ AI æ¨¡å‹ç®¡ç†å™¨é€²è¡Œåˆ†æ
    const response = await aiManager.analyze(modelType, {
      prompt,
      temperature: 0.7,
      maxTokens: getMaxTokensForModel(modelType),
    });

    console.log('[Channel Analysis] âœ… åˆ†æå®Œæˆ');
    console.log(`[Channel Analysis] æ¨¡å‹: ${response.model}`);
    console.log(`[Channel Analysis] æä¾›è€…: ${response.provider}`);
    console.log(
      `[Channel Analysis] Token ä½¿ç”¨: ${response.usage?.totalTokens || 'N/A'}`
    );
    if (response.cost) {
      console.log(`[Channel Analysis] æˆæœ¬: $${response.cost.toFixed(6)}`);
    }
    console.log(`[Channel Analysis] çµæœé•·åº¦: ${response.text.length} å­—å…ƒ`);

    res.json({
      success: true,
      analysis: response.text,
      metadata: {
        model: response.model,
        provider: response.provider,
        analysisType,
        usage: response.usage,
        cost: response.cost,
        timestamp: new Date().toISOString(),
      },
    });
  } catch (error) {
    console.error('[Channel Analysis] âŒ åˆ†æå¤±æ•—:', error);
    res.status(500).json({
      success: false,
      error: 'é »é“åˆ†æå¤±æ•—',
      details: error.message,
    });
  }
});

/**
 * é »é“åˆ†æï¼ˆSSE ä¸²æµç‰ˆï¼‰
 * POST /api/analyze-channel/stream
 */
app.post('/api/analyze-channel/stream', async (req, res) => {
  const {
    startDate,
    endDate,
    channelId,
    videos,
    channelStats,
    analytics,
    modelType = 'gemini-2.5-flash',
    analysisType = 'comprehensive',
  } = req.body;

  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.flushHeaders?.();

  const sendEvent = (event, data) => {
    res.write(`event: ${event}\n`);
    res.write(`data: ${JSON.stringify(data)}\n\n`);
  };

  const heartbeat = setInterval(() => {
    sendEvent('ping', {});
  }, 25000);

  const cleanup = () => {
    clearInterval(heartbeat);
  };

  const abortController = new AbortController();
  req.on('close', () => {
    abortController.abort();
    cleanup();
  });

  try {
    if (!startDate || !endDate) {
      throw new Error('Missing startDate or endDate');
    }

    if (!videos || !Array.isArray(videos)) {
      throw new Error('Missing or invalid videos array');
    }

    sendEvent('stage', { id: 'prepare', status: 'active' });

    const prompt = PromptTemplates.generatePrompt({
      type: analysisType,
      dateRange: { startDate, endDate },
      channelStats,
      videos,
      analytics,
    });

    sendEvent('stage', { id: 'prepare', status: 'completed' });
    sendEvent('stage', { id: 'request', status: 'active' });

    let finalResult = null;

    await aiManager.streamAnalyze(
      modelType,
      {
        prompt,
        temperature: 0.7,
        maxTokens: getMaxTokensForModel(modelType),
        abortSignal: abortController.signal,
      },
      {
        onChunk: (text) => {
          if (text) {
            sendEvent('chunk', { text });
          }
        },
        onComplete: (result) => {
          finalResult = result;
        },
      }
    );

    sendEvent('stage', { id: 'request', status: 'completed' });
    sendEvent('stage', { id: 'render', status: 'active' });

    if (!finalResult) {
      throw new Error('åˆ†æçµæœç‚ºç©º');
    }

    sendEvent('complete', {
      text: finalResult.text,
      metadata: {
        model: finalResult.model,
        provider: finalResult.provider,
        usage: finalResult.usage,
        cost: finalResult.cost,
        finishReason: finalResult.finishReason,
        analysisType,
        timestamp: new Date().toISOString(),
      },
    });

    sendEvent('stage', { id: 'render', status: 'completed' });
    sendEvent('end', { success: true });
    cleanup();
    res.end();
  } catch (error) {
    const isAbortError =
      error.name === 'AbortError' ||
      (typeof error.message === 'string' && error.message.includes('ä¸²æµå·²ä¸­æ­¢'));

    if (!isAbortError) {
      console.error('[Channel Analysis SSE] âŒ ä¸²æµåˆ†æå¤±æ•—:', error);
      sendEvent('error', {
        message: error.message || 'ä¸²æµåˆ†æå¤±æ•—',
      });
    } else {
      console.warn('[Channel Analysis SSE] ä¸²æµè¢«ä¸­æ­¢');
    }
    cleanup();
    res.end();
  }
});

/**
 * å¤šæ¨¡å‹å”åŒåˆ†æ
 * POST /api/analyze-channel/multi-model
 */
app.post('/api/analyze-channel/multi-model', async (req, res) => {
  const {
    startDate,
    endDate,
    channelId,
    videos,
    channelStats,
    analytics,
    models, // ç”¨æˆ¶æŒ‡å®šçš„æ¨¡å‹åˆ—è¡¨
  } = req.body;

  try {
    console.log(`\n========== ğŸ“Š é–‹å§‹å¤šæ¨¡å‹å”åŒåˆ†æ ==========`);

    // å¦‚æœæ²’æœ‰æŒ‡å®šæ¨¡å‹ï¼Œä½¿ç”¨æ‰€æœ‰å¯ç”¨æ¨¡å‹
    let modelsToUse = models;
    if (!modelsToUse || modelsToUse.length === 0) {
      const availableModels = aiManager.getAvailableModels();
      modelsToUse = availableModels.map((m) => m.id);
    }

    console.log(`[Multi-Model Analysis] ä½¿ç”¨æ¨¡å‹: ${modelsToUse.join(', ')}`);

    // ä¸¦è¡ŒåŸ·è¡Œå¤šå€‹æ¨¡å‹åˆ†æ
    const analysisPromises = modelsToUse.map(async (modelType) => {
      try {
        const prompt = PromptTemplates.generatePrompt({
          type: 'comprehensive',
          dateRange: { startDate, endDate },
          channelStats,
          videos,
          analytics,
        });

        const response = await aiManager.analyze(modelType, {
          prompt,
          temperature: 0.7,
          maxTokens: getMaxTokensForModel(modelType),
        });

        return {
          model: response.model,
          provider: response.provider,
          analysis: response.text,
          usage: response.usage,
          cost: response.cost,
          success: true,
        };
      } catch (error) {
        console.error(`[Multi-Model Analysis] ${modelType} åˆ†æå¤±æ•—:`, error);
        return {
          model: modelType,
          error: error.message,
          success: false,
        };
      }
    });

    const results = await Promise.all(analysisPromises);

    const successCount = results.filter((r) => r.success).length;
    const totalCost = results.reduce((sum, r) => sum + (r.cost || 0), 0);

    console.log('[Multi-Model Analysis] âœ… åˆ†æå®Œæˆ');
    console.log(`[Multi-Model Analysis] æˆåŠŸ: ${successCount}/${results.length}`);
    if (totalCost > 0) {
      console.log(`[Multi-Model Analysis] ç¸½æˆæœ¬: $${totalCost.toFixed(6)}`);
    }

    res.json({
      success: true,
      results,
      summary: {
        total: results.length,
        successful: successCount,
        failed: results.length - successCount,
        totalCost,
      },
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    console.error('[Multi-Model Analysis] âŒ åˆ†æå¤±æ•—:', error);
    res.status(500).json({
      success: false,
      error: 'å¤šæ¨¡å‹åˆ†æå¤±æ•—',
      details: error.message,
    });
  }
});

/**
 * AI é—œéµå­—å ±è¡¨åˆ†æï¼ˆæ”¯æ´å¤šæ¨¡å‹ï¼‰
 * POST /api/analyze-keywords
 */
app.post('/api/analyze-keywords', async (req, res) => {
  const {
    keywordGroups,      // é—œéµå­—çµ„åˆåˆ—è¡¨
    dateColumns,        // æ—¥æœŸåˆ—åˆ—è¡¨
    analyticsData,      // åˆ†ææ•¸æ“šï¼ˆ{ groupId: { columnId: { views, likes, ... } } }ï¼‰
    selectedMetrics,    // é¸ä¸­çš„æŒ‡æ¨™
    modelType = 'gemini-2.5-flash', // ä½¿ç”¨çš„æ¨¡å‹
  } = req.body;

  try {
    console.log(`\n========== ğŸ” é–‹å§‹é—œéµå­—å ±è¡¨åˆ†æ ==========`);
    console.log(`[Keyword Analysis] æ¨¡å‹: ${modelType}`);
    console.log(`[Keyword Analysis] é—œéµå­—çµ„åˆæ•¸: ${keywordGroups?.length || 0}`);
    console.log(`[Keyword Analysis] æ—¥æœŸåˆ—æ•¸: ${dateColumns?.length || 0}`);

    // é©—è­‰å¿…è¦åƒæ•¸
    if (!keywordGroups || keywordGroups.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'è«‹æä¾›è‡³å°‘ä¸€å€‹é—œéµå­—çµ„åˆ',
      });
    }

    if (!dateColumns || dateColumns.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'è«‹æä¾›è‡³å°‘ä¸€å€‹æ—¥æœŸç¯„åœ',
      });
    }

    if (!analyticsData) {
      return res.status(400).json({
        success: false,
        error: 'è«‹æä¾›åˆ†ææ•¸æ“š',
      });
    }

    // ç”Ÿæˆé—œéµå­—åˆ†æ Prompt
    const prompt = PromptTemplates.buildContentUnitPrompt({
      keywordGroups,
      dateColumns,
      analyticsData,
      selectedMetrics: selectedMetrics || ['views', 'likes', 'comments'],
    });

    console.log('[Keyword Analysis] ğŸ“¤ ç™¼é€è«‹æ±‚åˆ° AI æ¨¡å‹...');

    // èª¿ç”¨ AI æ¨¡å‹åˆ†æ
    const response = await aiManager.analyze(modelType, {
      prompt,
      temperature: 0.7,
      maxTokens: getMaxTokensForModel(modelType),
    });

    console.log('[Keyword Analysis] âœ… åˆ†æå®Œæˆ');
    console.log(`[Keyword Analysis] æ¨¡å‹: ${response.model}`);
    console.log(`[Keyword Analysis] æä¾›è€…: ${response.provider}`);
    if (response.usage) {
      console.log(`[Keyword Analysis] Token ä½¿ç”¨: ${response.usage.totalTokens || 'N/A'}`);
    }
    if (response.cost) {
      console.log(`[Keyword Analysis] æˆæœ¬: $${response.cost.toFixed(6)}`);
    }
    console.log(`[Keyword Analysis] çµæœé•·åº¦: ${response.text?.length || 0} å­—å…ƒ`);

    res.json({
      success: true,
      analysis: response.text,
      metadata: {
        model: response.model,
        provider: response.provider,
        usage: response.usage,
        cost: response.cost,
        keywordGroupCount: keywordGroups.length,
        dateColumnCount: dateColumns.length,
        timestamp: new Date().toISOString(),
      },
    });
  } catch (error) {
    console.error('[Keyword Analysis] âŒ åˆ†æå¤±æ•—:', error);
    res.status(500).json({
      success: false,
      error: 'é—œéµå­—åˆ†æå¤±æ•—',
      details: error.message,
    });
  }
});

/**
 * AI é—œéµå­—å ±è¡¨åˆ†æï¼ˆSSE ä¸²æµç‰ˆï¼‰
 * POST /api/analyze-keywords/stream
 */
app.post('/api/analyze-keywords/stream', async (req, res) => {
  const {
    keywordGroups,
    dateColumns,
    analyticsData,
    selectedMetrics,
    modelType = 'gemini-2.5-flash',
  } = req.body;

  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.flushHeaders?.();

  const sendEvent = (event, data) => {
    res.write(`event: ${event}\n`);
    res.write(`data: ${JSON.stringify(data)}\n\n`);
  };

  const heartbeat = setInterval(() => {
    sendEvent('ping', {});
  }, 25000);

  const cleanup = () => {
    clearInterval(heartbeat);
  };

  const abortController = new AbortController();
  req.on('close', () => {
    abortController.abort();
    cleanup();
  });

  const failAndEnd = (message) => {
    sendEvent('error', { message });
    sendEvent('end', { success: false });
    cleanup();
    res.end();
  };

  try {
    if (!keywordGroups || keywordGroups.length === 0) {
      return failAndEnd('è«‹æä¾›è‡³å°‘ä¸€å€‹é—œéµå­—çµ„åˆ');
    }
    if (!dateColumns || dateColumns.length === 0) {
      return failAndEnd('è«‹æä¾›è‡³å°‘ä¸€å€‹æ—¥æœŸç¯„åœ');
    }
    if (!analyticsData) {
      return failAndEnd('è«‹æä¾›åˆ†ææ•¸æ“š');
    }

    sendEvent('stage', { id: 'prepare', status: 'active' });

    const prompt = PromptTemplates.buildContentUnitPrompt({
      keywordGroups,
      dateColumns,
      analyticsData,
      selectedMetrics: selectedMetrics || ['views', 'likes', 'comments'],
    });

    sendEvent('stage', { id: 'prepare', status: 'completed' });
    sendEvent('stage', { id: 'request', status: 'active' });

    let finalResult = null;

    await aiManager.streamAnalyze(
      modelType,
      {
        prompt,
        temperature: 0.7,
        maxTokens: getMaxTokensForModel(modelType),
        abortSignal: abortController.signal,
      },
      {
        onChunk: (text) => {
          if (text) {
            sendEvent('chunk', { text });
          }
        },
        onComplete: (result) => {
          finalResult = result;
        },
      }
    );

    sendEvent('stage', { id: 'request', status: 'completed' });
    sendEvent('stage', { id: 'render', status: 'active' });

    if (!finalResult) {
      throw new Error('åˆ†æçµæœç‚ºç©º');
    }

    sendEvent('complete', {
      text: finalResult.text,
      metadata: {
        model: finalResult.model,
        provider: finalResult.provider,
        usage: finalResult.usage,
        cost: finalResult.cost,
        keywordGroupCount: keywordGroups.length,
        dateColumnCount: dateColumns.length,
        selectedMetricsCount: selectedMetrics?.length || 0,
        timestamp: new Date().toISOString(),
      },
    });

    sendEvent('stage', { id: 'render', status: 'completed' });
    sendEvent('end', { success: true });
    cleanup();
    res.end();
  } catch (error) {
    const isAbortError =
      error.name === 'AbortError' ||
      (typeof error.message === 'string' && error.message.includes('ä¸²æµ'));

    if (!isAbortError) {
      console.error('[Keyword Analysis SSE] âŒ ä¸²æµåˆ†æå¤±æ•—:', error);
      failAndEnd(error.message || 'ä¸²æµåˆ†æå¤±æ•—');
    } else {
      console.warn('[Keyword Analysis SSE] ä¸²æµè¢«ä¸­æ­¢');
      cleanup();
      res.end();
    }
  }
});

/**
 * é »é“æ•¸æ“šèšåˆï¼ˆæ”¯æ´é—œéµå­—éæ¿¾å’Œå¤šå€‹æ—¥æœŸç¯„åœï¼‰
 * POST /api/channel-analytics/aggregate
 */
app.post('/api/channel-analytics/aggregate', async (req, res) => {
  try {
    const { accessToken, channelId, keywordGroups, dateRanges } = req.body;

    // é©—è­‰åƒæ•¸
    if (!accessToken) {
      return res.status(400).json({ error: 'ç¼ºå°‘ accessToken' });
    }

    if (!channelId) {
      return res.status(400).json({ error: 'ç¼ºå°‘ channelId' });
    }

    if (!keywordGroups || !Array.isArray(keywordGroups) || keywordGroups.length === 0) {
      return res.status(400).json({ error: 'ç¼ºå°‘ keywordGroups æˆ–æ ¼å¼éŒ¯èª¤' });
    }

    if (!dateRanges || !Array.isArray(dateRanges) || dateRanges.length === 0) {
      return res.status(400).json({ error: 'ç¼ºå°‘ dateRanges æˆ–æ ¼å¼éŒ¯èª¤' });
    }

    // é©—è­‰ keywordGroups æ ¼å¼
    for (const group of keywordGroups) {
      if (!group.name || typeof group.name !== 'string') {
        return res.status(400).json({ error: 'keywordGroups ä¸­çš„ name å¿…é ˆç‚ºå­—ç¬¦ä¸²' });
      }
      if (typeof group.keyword !== 'string') {
        return res.status(400).json({ error: 'keywordGroups ä¸­çš„ keyword å¿…é ˆç‚ºå­—ç¬¦ä¸²' });
      }
    }

    // é©—è­‰ dateRanges æ ¼å¼
    for (const range of dateRanges) {
      if (!range.label || typeof range.label !== 'string') {
        return res.status(400).json({ error: 'dateRanges ä¸­çš„ label å¿…é ˆç‚ºå­—ç¬¦ä¸²' });
      }
      if (!range.startDate || typeof range.startDate !== 'string') {
        return res.status(400).json({ error: 'dateRanges ä¸­çš„ startDate å¿…é ˆç‚ºå­—ç¬¦ä¸² (YYYY-MM-DD)' });
      }
      if (!range.endDate || typeof range.endDate !== 'string') {
        return res.status(400).json({ error: 'dateRanges ä¸­çš„ endDate å¿…é ˆç‚ºå­—ç¬¦ä¸² (YYYY-MM-DD)' });
      }
    }

    console.log('\n========== ğŸ“Š é–‹å§‹èšåˆé »é“æ•¸æ“š ==========');
    console.log(`[Channel Analytics] é »é“ ID: ${channelId}`);
    console.log(`[Channel Analytics] é—œéµå­—çµ„åˆæ•¸: ${keywordGroups.length}`);
    console.log(`[Channel Analytics] æ—¥æœŸç¯„åœæ•¸: ${dateRanges.length}`);

    const result = await aggregateChannelData(
      accessToken,
      channelId,
      keywordGroups,
      dateRanges
    );

    console.log('[Channel Analytics] âœ… æ•¸æ“šèšåˆå®Œæˆ');
    res.json(result);
  } catch (error) {
    console.error('[Channel Analytics] âŒ æ•¸æ“šèšåˆå¤±æ•—:', error);
    res.status(500).json({
      error: error.message || 'æ•¸æ“šèšåˆå¤±æ•—',
      details: error.toString(),
    });
  }
});

/**
 * æ¸…é™¤æ•¸æ“šèšåˆå¿«å–
 * POST /api/channel-analytics/clear-cache
 */
app.post('/api/channel-analytics/clear-cache', (_req, res) => {
  try {
    const result = clearAnalyticsCache();
    res.json({
      success: true,
      message: `å·²æ¸…é™¤ ${result.cleared} ç­†å¿«å–`,
      cleared: result.cleared,
    });
  } catch (error) {
    console.error('[Channel Analytics] âŒ æ¸…é™¤å¿«å–å¤±æ•—:', error);
    res.status(500).json({
      error: error.message || 'æ¸…é™¤å¿«å–å¤±æ•—',
    });
  }
});

/**
 * å½±ç‰‡å¿«å–æœå°‹ API
 * GET /api/video-cache/search
 * Query params: query, maxResults
 */
app.get('/api/video-cache/search', async (req, res) => {
  try {
    const { query, maxResults = 10000 } = req.query;
    const gistId = process.env.GITHUB_GIST_ID;
    const gistToken = process.env.GITHUB_GIST_TOKEN || null;

    console.log('[API] ğŸ” æ”¶åˆ°å¿«å–æœå°‹è«‹æ±‚');
    console.log(`[API] ğŸ†” Gist ID: ${gistId || '(æœªè¨­å®š)'}`);
    console.log(`[API] ğŸ”‘ æœå°‹é—œéµå­—: ${query || '(ç„¡)'}`);
    console.log(`[API] ğŸ“Š æœ€å¤§çµæœæ•¸: ${maxResults}`);

    if (!gistId) {
      console.log('[API] âŒ ç¼ºå°‘ GITHUB_GIST_ID ç’°å¢ƒè®Šæ•¸');
      return res.status(400).json({
        error: 'ç¼ºå°‘ GITHUB_GIST_ID ç’°å¢ƒè®Šæ•¸',
        videos: [],
      });
    }

    const videos = await searchVideosFromCache(
      gistId,
      query || '',
      parseInt(maxResults) || 10000,
      gistToken
    );

    console.log(`[API] âœ… æœå°‹å®Œæˆï¼Œè¿”å› ${videos.length} ç­†çµæœ`);

    res.json({
      success: true,
      query: query || '',
      totalResults: videos.length,
      videos: videos,
    });
  } catch (error) {
    console.error('[API] âŒ å¿«å–æœå°‹éŒ¯èª¤:', error.message);
    res.status(500).json({
      error: error.message || 'æœå°‹å½±ç‰‡å¿«å–å¤±æ•—',
      videos: [],
    });
  }
});

// æœå‹™å‰ç«¯éœæ…‹æª”æ¡ˆï¼ˆVite build è¼¸å‡ºçš„ distï¼‰
app.use(express.static(path.join(process.cwd(), 'dist')));

// å–®é æ‡‰ç”¨ç¨‹å¼è·¯ç”± fallbackï¼ˆæœ€å¾Œè¨»å†Šï¼Œé¿å…åƒæ‰ /api/*ï¼‰
app.get('*', (_req, res) => {
  const indexPath = path.join(process.cwd(), 'dist', 'index.html');
  if (fs.existsSync(indexPath)) {
    res.sendFile(indexPath);
  } else {
    res.status(404).send('Build not found. Please run the build process.');
  }
});

// ==================== å•Ÿå‹•æ™‚æ¸…ç†éæœŸæª”æ¡ˆ ====================

/**
 * æ¸…ç†æŒ‡å®šç›®éŒ„ä¸­è¶…éä¿ç•™å¤©æ•¸çš„æª”æ¡ˆ
 * @param {string} directory - è¦æ¸…ç†çš„ç›®éŒ„è·¯å¾‘
 * @param {number} retentionDays - ä¿ç•™å¤©æ•¸
 * @returns {Promise<{deletedCount: number, deletedSize: number}>}
 */
async function cleanupOldFiles(directory, retentionDays) {
  if (!fs.existsSync(directory)) {
    return { deletedCount: 0, deletedSize: 0 };
  }

  const now = Date.now();
  const retentionMs = retentionDays * 24 * 60 * 60 * 1000; // è½‰æ›ç‚ºæ¯«ç§’
  let deletedCount = 0;
  let deletedSize = 0;

  try {
    const files = fs.readdirSync(directory);

    for (const file of files) {
      const filePath = path.join(directory, file);

      try {
        const stats = fs.statSync(filePath);

        // åªè™•ç†æª”æ¡ˆï¼Œè·³éç›®éŒ„
        if (!stats.isFile()) {
          continue;
        }

        // è¨ˆç®—æª”æ¡ˆå¹´é½¡
        const fileAge = now - stats.mtime.getTime();

        // å¦‚æœæª”æ¡ˆè¶…éä¿ç•™å¤©æ•¸ï¼Œå‰‡åˆªé™¤
        if (fileAge > retentionMs) {
          const fileSize = stats.size;
          fs.unlinkSync(filePath);
          deletedCount++;
          deletedSize += fileSize;

          const ageInDays = Math.floor(fileAge / (24 * 60 * 60 * 1000));
          console.log(`  ğŸ—‘ï¸  å·²åˆªé™¤: ${file} (${(fileSize / (1024 * 1024)).toFixed(2)} MB, ${ageInDays} å¤©å‰)`);
        }
      } catch (err) {
        console.error(`  âš ï¸  ç„¡æ³•è™•ç†æª”æ¡ˆ ${file}:`, err.message);
      }
    }
  } catch (err) {
    console.error(`[Cleanup] è®€å–ç›®éŒ„å¤±æ•— ${directory}:`, err.message);
  }

  return { deletedCount, deletedSize };
}

/**
 * å•Ÿå‹•æ™‚åŸ·è¡Œæ¸…ç†ä»»å‹™
 */
async function startupCleanup() {
  console.log('\n========== ğŸ§¹ å•Ÿå‹•æ¸…ç†æª¢æŸ¥ ==========');
  console.log(`[Cleanup] æª”æ¡ˆä¿ç•™å¤©æ•¸: ${FILE_RETENTION_DAYS} å¤©`);

  // æ¸…ç†æš«å­˜å½±ç‰‡
  console.log('[Cleanup] æª¢æŸ¥ temp_videos ç›®éŒ„...');
  const tempResult = await cleanupOldFiles(DOWNLOAD_DIR, FILE_RETENTION_DAYS);

  // æ¸…ç†æˆªåœ–
  console.log('[Cleanup] æª¢æŸ¥ public/images ç›®éŒ„...');
  const imagesResult = await cleanupOldFiles(IMAGES_DIR, FILE_RETENTION_DAYS);

  // çµ±è¨ˆç¸½è¨ˆ
  const totalDeleted = tempResult.deletedCount + imagesResult.deletedCount;
  const totalSize = (tempResult.deletedSize + imagesResult.deletedSize) / (1024 * 1024);

  if (totalDeleted > 0) {
    console.log(`[Cleanup] âœ… æ¸…ç†å®Œæˆ: åˆªé™¤ ${totalDeleted} å€‹æª”æ¡ˆï¼Œé‡‹æ”¾ ${totalSize.toFixed(2)} MB ç©ºé–“`);
  } else {
    console.log('[Cleanup] âœ… ç„¡éœ€æ¸…ç†ï¼Œæ‰€æœ‰æª”æ¡ˆéƒ½åœ¨ä¿ç•™æœŸé™å…§');
  }
  console.log('========== æ¸…ç†æª¢æŸ¥å®Œæˆ ==========\n');
}

// å•Ÿå‹•ä¼ºæœå™¨å‰å…ˆåŸ·è¡Œæ¸…ç†
startupCleanup().then(() => {
  app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
    console.log(`Make sure yt-dlp is installed: https://github.com/yt-dlp/yt-dlp#installation`);
  });
}).catch((err) => {
  console.error('âŒ Cleanup failed:', err);
  // å³ä½¿æ¸…ç†å¤±æ•—ä¹Ÿè¦å•Ÿå‹•ä¼ºæœå™¨
  app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
    console.log(`Make sure yt-dlp is installed: https://github.com/yt-dlp/yt-dlp#installation`);
  });
});
